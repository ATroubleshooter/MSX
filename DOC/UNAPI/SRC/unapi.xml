<?xml version="1.0"?>

<!--
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
-->

<?rfc toc="yes" ?>
<?rfc topblock="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc private="Version 1.1" ?>

<rfc xmlns="http://www.rfc2629.org"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.rfc2629.org rfc2629.xsd"
  ipr="full3978" docName="UNAPI">

	<!-- Header -->

	<front>
		<title abbrev="MSX-UNAPI">MSX-UNAPI: Unified procedure for API definition and discovery on MSX computers</title>
		<author initials="N." surname="Soriano" fullname="Nestor Soriano">
			<organization>MSX community</organization>
			<address>
				<email>konamiman@konamiman.com</email>
				<uri>http://www.konamiman.com</uri>
			</address>
		</author>
		<date month="February" year="2010" />
		<abstract>
			<t>This document describes MSX-UNAPI, a standard procedure for defining, discovering and using new APIs (Application Program Interfaces)
			for MSX computers. The goal is to provide a unified way to design and use BIOS-like software for the various kinds of new hardware that is
			being developed for these computers, altough it can be used for software-only solutions as well.</t>
		</abstract>
	</front>

	<middle>
	
		<!-- Introduction -->
	
		<section anchor="intro" title="Introduction">
			<section anchor="motivation" title="Motivation">
				<t>MSX was presented in 1983 as a standard for home computers, in the form of a set of specifications to be followed by manufacturers.
				Any brand was able to make its own model of computer; as long as the machine met the MSX standard, it was considered an MSX computer.
				This allowed for flawless interoperation between computers of different makers, something not as common at the time as it is nowadays.</t>
				
				<t>An important part of the MSX specification was the BIOS, a set of routines that -amongst other things- provided a standarized way
				to access the harwdare resources of the machine. This provided certain degree of freedom to manufacturers, which could -to some extent-
				freely choose the hardware parts that would build up their given model of MSX computer.</t>
				
				<t>Time passed and the MSX standard was discontinued by all manufacturers long time ago. However, many people still using their old MSX computers,
				and some of them even develop new hardware for these machines. Hard disk interfaces, sound cards and network cards are examples of hardware
				that has been developed for MSX computers past the commercial live of the standard.</t>
				
				<t>Altough the appearance of new hardware is of course a good thing, this causes a problem for software developers. Not having any authority
				dictating specifications for the MSX standard anymore, each hardware developer freely choses the way their hardware will have to be
				accessed from software; in other words, there are no specifications to follow at the time of designing the API (Application Program Interface)
				for the new harwdare. As a result, hardware extensions performing the same functions but being developed by different persons are software-incompatible
				(unless developers privately agree on using compatible APIs, which is not always possible).</t>
				
				<t>The intent of this document is to propose a solution for this problem:
				a standard, unified procedure for defining, discovering and using new APIs for MSX computers, aimed especially (but not exclusively)
				to the hardware development field.</t>
			</section>
			
			<section anchor="goals" title="Goals">
				<t>The main goals of this specification are:</t>
				<vspace blankLines='1' />
					<list style="symbols">
						<t>To provide a minimum set of rules to be followed by APIs that adhere to this specification. These rules are to be taken in account
						when designing (and later implementing) the various APIs. They are very simple, impose only a few restrictions on compliant code,
						and in practice allow any kind of API software to be written.</t>
						<vspace blankLines='1' />
						<t>To provide a standard procedure for discovering and using APIs that adhere to this standard and are installed
						on the MSX computer running the UNAPI aware software. This procedure is based on the MSX extended BIOS mechanism,
						and is very easy to implement and even easier to use.</t>
					</list>
			</section>
			
			<section anchor="nongoals" title="Non-goals">
				<t>It is NOT the intent of this specification, and/or is outside the scope of this document:</t>
				<vspace blankLines='1' />
					<list style="symbols">
						<t>To impose the described specification to developers or users. Altough the authors hope that the MSX-UNAPI specification
						will be useful for the MSX community, this document is merely a proposal, and adhering to it is of course optional.</t>
						<vspace blankLines='1' />
						<t>To arbiter who should desing the APIs. Common sense suggests that APIs should be designed by the first person or team that develops
						a given type of hardware (or software), but the decision of such thing is outside the scope of this document.</t>
						<vspace blankLines='1' />
						<t>To describe any API other than for illustration purposes. This documents just tells a procedure for designing APIs;
						these must be described in sepparate documents.</t> 
					</list>
			</section>
			
			<section anchor="glossary" title="Glossary">
				<t>Before proceeding any further, a glossary of terms used along this document will be introduced. It will be useful
				to understand the rules and procedures described later.</t>
				<t>MSX-UNAPI</t>
					<list style="empty"><t>Short for "MSX unified API definition and discovery standard". A set of rules to be followed when designing
					and implementing APIs, aimed mainly (but not exclusively) to hardware developers; and a procedure for discovering any such APIs available
					to application software.</t></list>
				<t>API specification</t>
					<list style="empty"><t>API stands for "Application Program Interface". The description of a set of routines that perform some action
					(which usually, but not necessarily, involve accessing some kind of hardware), including the precise description
					of input and output parameters, as well as the side effects caused by the execution of each routine.</t></list>
				<t>UNAPI compliant API specification</t>
					<list style="empty"><t>An API specification that conforms to the rules for API specifications described in this document.</t></list>
				<t>API specification identifier</t>
					<list style="empty"><t>An alphanumeric, case-insensitive string made of up to 15 characters, which uniquely identifies an UNAPI compliant
					API specification. For example the identifier of an API specification for Ethernet cards could be "ETHERNET". See <xref target="apirule1" />
					for more details.</t></list>
				<t>The XXXXX UNAPI specification</t>
					<list style="empty"><t>The specification for an UNAPI compliant API whose specification identifier is XXXXX.
					For example, "the Ethernet UNAPI specification".</t></list>
				<t>XXXXX UNAPI compliant API implementation</t>
					<list style="empty"><t>Real code that builds up a set of routines which conforms to an UNAPI compliant API specification (and more
					precisely, to the XXXXX UNAPI specification). There may be several implementations of one single specification, each made by a
					different person or team; but if they strictly conform to the API specification, they are indistinguishable with respect to usage
					and behavior.</t></list>
				<t>API implementation name</t>
					<list style="empty"><t>An alphanumeric string made of up to 63 characters, which uniquely identifies an API implementation.
					For example the name of an implementation of the Ethernet UNAPI could be "ObsoNET", while the name of
					other implementation could be "UltraNET Supercard". See <xref target="apirule5" /> for more details.</t></list>
				<t>XXXXX UNAPI client software</t>
					<list style="empty"><t>Application software that invokes the routines of an XXXXX UNAPI compliant API implementation.
					For example, a TCP/IP stack could act as client software of the Ethernet UNAPI. The client software must use
					the discovery procedure (see <xref target="discovery" />) to locate the available API implementations, and usually it does not matter which
					one is used if more than one is found.</t></list>
        <t>Specificationless UNAPI application</t>
        <list style="empty">
          <t>
            Application software (typically, a resident application) that does not conform to any concrete UNAPI specification,
            but that make use of the remaining of the UNAPI infrastructure, namely, the implementation and discovery rules.
            See <xref target="specless" /> for more details.
        </t>
        </list>
        <t>#FF</t>
					<list style="empty"><t>Character # is used in this document as a prefix for hexadecimal numbers, so for example #FF is 255.</t></list>
				<t>Through this document, and unless otherwise stated, the term "API specification" will actually have the meaning of "UNAPI compliant API specification".
				The same applies to references to API implementations.</t>
			</section>
			
			<section anchor="samplescenario" title="Sample scenario">
				<t>This section provides an fictional scenary that briefly shows the steps that are needed in order to design and implement UNAPI compliant APIs.
				The goal is to provide the reader a basic understanding about how all the whole thing works, so that it is easier to read
				the detailed rules and procedures that are provided in the remaining of the document.</t>
				<t>Suppose that a user named H.G. Wells builds a time machine for MSX computers. He wants to make the software to control it to be UNAPI compliant.
				To achieve this, since it is the first time machine ever developed for MSX, he first must design the API specification. These are the steps he follows for it:</t>
				<vspace blankLines='1' />
				<list style="numbers">
					<t>Chooses a short name for the API specification. He chooses "TIME_MACHINE". (see <xref target="apirule1" />)</t>
					<vspace blankLines='1' />
					<t>Designs the routines that will compose the API. He designs three routines: travel backwards, travel forwards, and return to original time.
					These routines will have routine numbers 1 through 3. (see <xref target="apirule2" />, <xref target="apirule3" /> and <xref target="apirule4" />)</t>
				</list>
				<t>Now he must write a real implementation of the API, to be included in ROM together with the time-travel hardware. He does then the following:</t>
				<vspace blankLines='1' />
				<list style="numbers">
					<t>Chooses a name for the API implementation: "Well's Time Machine BIOS" (see <xref target="apirule5" />)</t>
					<vspace blankLines='1' />
					<t>Implements the actual code for the three API routines 
					(again, see <xref target="apirule2" />, <xref target="apirule3" /> and <xref target="apirule4" />)</t>
					<vspace blankLines='1' />
					<t>Implements the API discovery procedure, so that when the time machine is present in a MSX machine, it can be discovered
					by using extended BIOS (see <xref target="discovery" />)</t>
				</list>
				<t>The device turns out to sell quite well in MSX users meetings, and some users develop software that uses it, from multi-epoch games
				to virtual history books. All of this software uses the UNAPI discovery procedure (see <xref target="discovery" />) in order to find out at run time
				whether the time machine is present or not.</t>
				<t>Soon afterwards, another user with hardware design knowledge, Dr. Brown, develops another kind of time machine for MSX.
				Since he wants the software that already exists for Well's hardware to be compatible with his own device, he develops the software so that
				it is compatible with the TIME_MACHINE API specification, by following the same steps that Wells did. There are, however, some important differences with the Well's machine:</t>
				<vspace blankLines='1' />
				<list style="numbers">
					<t>The API implementation name is now "Brown's flux-capacited time machine".</t>
					<vspace blankLines='1' />
					<t>The device is connected to MSX via serial port, so it has no ROM and the API implementation is therefore installed in mapped RAM.
					When this API is installed, it installs the RAM helper. (see <xref target="ramhelper" />)</t>
					<vspace blankLines='1' />
					<t>There is an extra routine which is needed to calibrate the flux capacitor. This routine is implemented as an
					implementation-specific routine (see <xref target="apirule4" />), and has the routine number 128.</t>
				</list>
				<t>Now that there are two different time travel devices around, an user named M. McFly wants to develop a windowed graphic interface to
				control the time machines. It develops the software to discover, and interact with, TIME_MACHINE APIs; therefore it works with both
				kinds of devices. Moreover, as an extra feature, it checks the implementation name of the API implementation it uses
				(see <xref target="apirule1" />), and when it is the Brown's implementation, the application offers extra functionality
				to calibrate the flux capacitor.</t>
			</section>
		</section>

		<!-- API specification rules -->
		
		<section anchor="apirules" title="API specification rules">
			<t>This section describes the rules that must follow any UNAPI compliant API specification, as well as their implementations.</t>

			<section anchor="apirule1" title="Rule 1: The API identifier and version number">
				<t>An API specification must have an alphanumeric identifier composed of up to 15 characters. Allowed characters are
				letters (having an ASCII code below 128), digits, and the following ones: - _ / . ( )</t>
				<t>The API identifier is case-insensitive, so for example, "ETHERNET" is the same as "Ethernet".</t>
				<t>An API specification must have a version number composed of main version number in the range 1-255, and secondary version number
				in the range 0-255. Specifications with higher version numbers must be backwards compatible with older versions.
				The first released specification document should have version 1.0. Versions 0.x are allowed as pre-releases, with no guarantee
				of backwards compatibility between them.</t>
				<t>Digits may be used in the identifier when they are meaningful to describe the API (for example "WIFI_IEEE802.3"), but they must NOT
				be used to indicate the specification version.</t>
			</section>

			<section anchor="apirule2" title="Rule 2: One single entry point on Z80 page 1 or 3">
				<t>There must be one single entry point for the API routines. This entry point must be accessible in any address on one of these places:</t>
				<vspace blankLines='1' />
				<list style="symbols">
					<t>A ROM or non-mapped RAM slot, on Z80 page 1 (address between #4000 and #7FFF).</t>
					<vspace blankLines='1' />
					<t>A mapped RAM segment, provided that it will be connected to Z80 page 1 (address between #4000 and #7FFF) when called.</t>
					<vspace blankLines='1' />
					<t>System RAM on page 3 (address above #C000).</t>
				</list>
				<t>It is outside the scope of this specification to define how RAM memory (mapped RAM segments and space in system RAM on page 3) is allocated.</t>
				<t>If necessary, API routines may return a pointer to hard-coded information to be read by the client software (as the mandatory API information
				routine does with the API implementation name, see <xref target="apirule5" />). In this case, the information must be in the same place as the API implementation itself.
				That is, in the same ROM slot (in Z80 page 1), in the same RAM segment (if this is the case, a page 1 address is returned), or in system RAM on page 3.
				This way it is easy to obtain the name by using inter-slot or inter-segment (see <xref target="ramhelper" />) reads.</t>
				<t>As an exception to the above rule, API implementations residing in page 1 (ROM or a mapped RAM segment) may return an address in system RAM on page 3
				(this is useful when ROM implementations need to return dynamic data, for example). Therefore the client software must be always
				prepared to either perform inter-slot or inter-segment reads, or direct memory reads, in order to retrieve the data.</t>
				<t>If necessary, API routines may require the client software to specify a buffer where dynamic data will be read from, or written to
				(for example, packets to be sent to or retrieved from the network in the case of an Ethernet API). In this case, the API specification may impose
				a restriction to the client software, so that it must NOT specify any page 1 address as the buffer address.</t>
			</section>

			<section anchor="apirule3" title="Rule 3: Z80 registers usage">
				<t>Z80 registers are used by the API routines in the following way:</t>
				<vspace blankLines='1' />
				<list style="symbols">
					<t>Register A is used at input to specify the routine to be executed. Each routine has associated a number in the range 0-254;
					how these numbers are allocated is described in <xref target="apirule4" />. It can be used also as an output parameter, otherwise it is corrupted
					after the routine is executed.</t>
					<vspace blankLines='1' />
					<t>Registers F, BC, DE and HL may be used freely as input and/our output parameters. Registers not used to hold output parameters
					are corrupted after the routine is executed, unless otherwise stated in the routine definition.</t>
					<vspace blankLines='1' />
					<t>Registers IX, IY must not be used for input parameters, to allow for inter-slot and inter-segment calls. They can be used
					as output parameters, otherwise they are corrupted after the routine is executed.</t>
					<vspace blankLines='1' />
					<t>Alternate registers (AF', BC', DE' and HL') are corrupted after the routine is executed.</t>
				</list>
				<t>"The registers are corrupted after the routine is executed" means that the routine code may freely make internal use of the registers,
				and it does not need to restore their original values before finishing.</t>
			</section>
			
			<section anchor="apirule4" title="Rule 4: Routine number ranges">
				<t>As stated before, each API routine has associated a number which must be passed in register A when calling the API entry point. The numeric range
				0-255 is divided in four ranges of routines:</t>
				<vspace blankLines='1' />
				<list style="symbols">
					<t>0: This value corresponds to the API information routine. It is a mandatory routine that must be present on all implementations
					of any UNAPI compliant API. The parameters and behavior of this routine are described in <xref target="apirule5" />.</t>
					<vspace blankLines='1' />
					<t>1-127: Specification routines. The behavior of these routines is defined in the appropriate API specification document.</t>
					<vspace blankLines='1' />
					<t>128-254: Implementation-specific routines. API implementation developers may freely use this range of routines to offer additional
					capabilities not present in the original API specification; if this is done, these routines must be described in the
					documentation of the implementation. For example, one implementation of the Ethernet UNAPI could use this range of routines to offer
					WiFi connectivity, while other could offer basic internetworking capability. Note that different implementations may use the same
					numbers for different routines, always inside this range.</t>
					<vspace blankLines='1' />
					<t>255: This value is reserved for a possible future extension mechanism.</t>
				</list>
				<t>Numbers must be assigned to routines in increasing order, starting with 1 for specification routines and starting with 128 for
				implementation-specific routines; it is not allowed to leave holes in the function number ranges.
				If client software invokes a non-existing routine (that is, calls the API implementation entry point passing in A a number
				not assigned to any routine), nothing must happen and the code must return with AF, BC, DE and HL unmodified.</t>
			</section>
			
			<section anchor="apirule5" title="Rule 5: The API information routine + the implementation name and version">
				<t>Every API implementation, no matter which API specification is implementing, must mandatorily implement the API information routine.
				This routine has always the routine number 0 and has the following input and output parameters:</t>
				<vspace blankLines='1' />
				<figure><artwork>Input:  A = 0
Output: HL = Address of the implementation name string
        DE = API specification version supported. D=primary, E=secondary.
        BC = API implementation version. B=primary, C=secondary.</artwork></figure>
        		<t>The implementation name string must be composed of up to 63 printable characters and must have a zero byte as termination.
        		The name may be any descriptive text, but must NOT contain any version information, and is case-sensitive.</t>
        		<t>The implementation name must be placed in the same place as the API implementation itself (see <xref target="apirule2" />).</t>
        		<t>Usually, client software will use the first suitable API implementation it founds, and will use the implementation name merely to show information
        		to the user. However, if the client software is able to use the implementation-specific features of any given implementation, it must check
        		the implementation name to know wether the desired implementation-specific routines are available or not.</t>
        		<t>Client software should check the API specification version supported by the implementation, since newer implementation versions
        		may have routines not available in older versions.</t>
        		<t>Rules for the implementation version are similar to rules for the specification version (see <xref target="apirule1" />): first release version should be 1.0,
        		and 0.x versions are allowed for pre-releases. However, the backwards compatibility rule now applies to implementation-specific routines only,
        		since the compatibility with the specification routines is indicated by the "API specification version supported" parameter.</t>
        		<t>It is not allowed for an API implementation to go backwards in the API specification version supported when the API implementation version
        		is increased. For example, if implementation version 2.0 supports specification version 1.5, it is illegal for implementation version 2.1
        		to claim compliance with the specification version 1.4; it must support specification version 1.5 or higher. Otherwise, backwards compatibility
        		between API implementations could not be assured.</t>
        	</section>
        	
			<section anchor="apirule6" title="Rule 6: Implement code for the API discovery procedure">
				<t>Every API implementation, no matter which API specification is implementing, must mandatorily support the API discovery procedure. See <xref target="discovery" />.</t>
			</section>
			
			<section anchor="apirule7" title="Rule 7: Install the RAM helper">
				<t>Every API implementation that is installed on a mapped RAM segment must, at installation time, check if the RAM helper is installed.
        If not, it must either install one, or refuse to install. See <xref target="ramhelper" />.</t>
			</section>
			
			<section anchor="apirule8" title="Rule 8: Avoid segment number #FF">			
				<t>An API implementation that installs on a mapped RAM segment must NOT be installed on a segment whose number is #FF (this is the last existing segment number
				on 4MByte RAM slots). This is necessary because the discovery procedure will use #FF as a fictitious segment number when the API implementation
				resides in ROM
				(see <xref target="discovery_steps" />).</t>
				<t>When using the mapper support routines provided by MSX-DOS 2 to allocate memory, this is not an issue, since these routines will never allocate
				segment #FF even when it is available. However, when running under DOS 1 and manually selecting the segment for installation,
				care must be taken to not use segment #FF.</t>
				is installed in ROM
			</section>
			
			<section anchor="apirule9" title="Optional rule 9: Give your routines a meaningful name">
				<t>In your API specification, you can refer to your ruotines simply by their numbers. However, to make the client software developers life easier,
				it is advisable to give your routines meaningful names. Tipically, these names will be directly used as constants in source code;
				therefore, the following guidelines should be followed when choosing the names:</t>
				
				<list style="symbols">
					<vspace blankLines='1' />
					<t>Use characters that are legal for all assemblers and compilers. Ideally, you should use only
					letters and the underscore symbol ("_"). Use uppercase letters to improve readability.</t>
					<vspace blankLines='1' />
					
					<t>Limit the length of the names to a reasonable maximum, for example 16 characters.</t>
					<vspace blankLines='1' />
					
					<t>Do not use names already in use for standard MSX BIOS routines, system work area variables or MSX-DOS function calls.</t>
					<vspace blankLines='1' />
					
					<t>It may be useful to prepend the routine names with the first characters of the implementation identifier.</t>
					<vspace blankLines='1' />
					
					<t>And of course, choose names that make sense for the routines being named.</t>
				</list>
				
				<t>For example, an Ethernet UNAPI specification could have the following routine names: ETH_RESET (reset hardware),
				ETH_GET_FRAME (retrieve incoming frame from the network), or ETH_GET_NETSTAT (check the network status).</t>

				<t>Note that this rule is optional, and so are the guidelines listed; you can break them if necessary, simply be wise
				and think on the other developers.</t>
			</section>
		</section>

		<!-- Discovery procedure -->
		
		<section anchor="discovery" title="API implementations discovery procedure">
			<t><xref target="apirules" /> described the rules for designing UNAPI compliant APIs. These API specifications are used by developers to make API implementations,
			which are composed of real code that once installed on an MSX computer (whatever the installation method is), becomes available to client software.</t>
			<t>This section describes the API implementations discovery procedure, that is, the steps that client software must follow to find out how many
			implementations of a given API specification are available at run time, and to gather information about each implementation (in which slot/segment are
			placed, where the entry point is, and the name and version information), as well as how API implementations can include support for this procedure.</t>
			
			<section anchor="discovery_extbio" title="The MSX extended BIOS">
				<t>The discovery procedure is based on the MSX extended BIOS, which is a mechanism available on MSX computers that allows standard BIOS to be
				extended with new routines. This section explains the general rules of the extended BIOS mechanism, and later sections explain how this is
				used for the UNAPI discovery protocol.</t>
				<t>Extended BIOS provides a five byte hook named EXTBIO at address #FFCA. To check whether this hook has been initialized with any value or is uninitialized,
				look at bit 0 of the byte at address HOKVLD (#FB20). A value of one for this bit means that the hook contains a valid jump instruction,
				previously set by system code or user code.</t>
				<t>The EXTBIO hook contents may be replaced with a jump instruction to custom code, provided that the old hook contents are saved somewhere.
				If the hook is not initialized, it should first be filled with five RET instructions, and bit 0 of HOKVLD should be set; from this point,
				consider it as being initialized.</t>
				<t>The EXTBIO hook is called with a code named "device identifier" in register D, a "function identifier" in register E, and input parameters in AF, BC and HL.
				The code called in this way must look at the device identifier to check if the request is for itself. If not, it must jump to the old hook
				(the one saved at installation time) with AF, BC, DE and HL unmodified.</t>
				<t>When the device identifier matches the one expected by the code, it performs the action requested (as per the function identifier) and
				either returns parameters in, or corrupts, AF, BC and HL; DE is always preserved.</t>
				<t>IX, IY and the alternate registers are always corrupted, no matter whether any suitable code for the specified device identifier is executed or not.</t>
				<t>This procedure allows to chain together multiple BIOS extensions, each having its own device identifier. These identifiers were once
				assigned by MSX manufacurers, and later on, users have developed software that patch extended BIOS, freely choosing their own identifiers.</t>
			</section>
			
			<section anchor="discovery_steps" title="Steps of the discovery procedure">
				<t>Client software willing to discover how many implementations of a certain API are available at run time must perform these steps:</t>
				<vspace blankLines='1' />
				<list style="numbers">
					<t>Copy the API specification identifier to address #F847. Append a zero byte as string terminator.</t>
					<vspace blankLines='1' />
					<t>Set Z80 registers as follows: A=0, B=0, DE=#2222.</t>
					<vspace blankLines='1' />
					<t>Call the EXTBIO hook.</t>
					<vspace blankLines='1' />
					<t>When EXTBIO returns, B contains the number of installed implementations of the specified API. DE is preserved and
					AF, C, HL are corrupted.</t>
				</list>
				<t>Address #F847 is a 16 byte buffer named ARG, used normally by Math-Pack (mathematic routines package of MSX BIOS).</t>
				<t>After the previous steps have been performed, and provided that at least one implementation is installed (B>0), 
				do the following to gather information about a given implementation:</t>
				<vspace blankLines='1' />
				<list style="numbers">
					<t>Make sure that the API specification identifier is still at ARG.</t>
					<vspace blankLines='1' />
					<t>Set Z80 registers as follows: A=implementation index (from 1 to the number of available implementations), DE=#2222.</t>
					<vspace blankLines='1' />
					<t>Call the EXTBIO hook.</t>
					<vspace blankLines='1' />
					<t>When EXTBIO returns, Z80 registers contain the following information about the specified implementation:</t>
					<vspace blankLines='1' />
					<list style="empty">
						<t>A  = Slot where the implementation code is placed</t>
						<t>B  = RAM segment where the implementation code is placed <list style="empty"><t>(#FF if not in mapped RAM)</t></list></t>
						<t>HL = Routines entry point address <list style="empty"><t>(if a page 3 address, A and B are meaningless)</t></list></t>
						<t>DE is preserved. F and C are corrupted.</t>
					</list>
				</list>
				<t>With this information, now you know how to call the implementation entry point in order to invoke the API routines:</t>
				<vspace blankLines='1' />
				<list style="symbols">
					<t>If the entry point address is a page 3 address, ignore A and B and perform direct calls to that address.</t>
					<vspace blankLines='1' />
					<t>Otherwise, if B=#FF, use inter-slot calls (for example by using the BIOS routine CALSLT) to invoke the routines.</t>
					<vspace blankLines='1' />
					<t>Otherwise, use inter-segment calls (you can use the RAM helper for this, see <xref target="ramhelper" />) to invoke the routines.</t>
				</list>
				<t>Usually, the first thing to do at this point is to call the API implementation information routine (see <xref target="apirule5" />) to obtain the implementation
				name and version (this is not mandatory, though). From here, client software can invoke the API routines as needed.</t>
			</section>
			
			<section anchor="discovery_implement" title="How to implement support for the discovery procedure">
				<t><xref target="discovery_steps" /> provided a functional description of the API implementations discovery procedure. For this procedure to work,
				all implementations of an UNAPI compliant API must include code to support this procedure. This section explains how this code
				should be implemented.</t>
				<t>First, when the API implementation is installed (or at system boot, for ROM based code), the existing EXTBIO hook must be backed up
				(if EXTBIO hook is not initialized, initialize it first as explained in <xref target="discovery_extbio" />). Then, put a jump instruction or an inter-slot or inter-segment call
				pointing to your EXTBIO manager code.</t>
				<t>Second, include in the API implementation code to manage EXTBIO calls (that's where the new EXTBIO hook points to). This code must perform the
				following steps:</t>
				<vspace blankLines='1' />
				<list style="numbers">
					<t>Check that register pair DE holds the value #2222. If not, jump to the old EXTBIO hook with AF, BC, DE, HL unmodified.</t>
					<vspace blankLines='1' />
					<t>If A=#FF, jump to the old EXTBIO hook with AF, BC, DE, HL unmodified (this is to allow the RAM helper to be installed, see <xref target="ramhelper" />).</t>
					<vspace blankLines='1' />					
					<t>Check that the string placed in ARG (remember that it is zero-terminated there) matches the identifier of the API specification that your code implements.
					If not, jump to the old EXTBIO hook with AF, BC, DE, HL unmodified. Remember that the strings comparison must be done in a case-insensitive way.</t>
					<vspace blankLines='1' />
					<t>If A=0, increase the value of register B by one, and jump to the old EXTBIO hook with A and DE unmodified.</t>
					<vspace blankLines='1' />
					<t>Otherwise, if A=1, put the appropriate information about the implementation in registers A, B, and HL, as described in <xref target="discovery_steps" />,
					and return (do NOT call the old EXTBIO hook) with DE unmodified.</t>
					<vspace blankLines='1' />
					<t>Otherwise, decrease A by one, and jump to the old EXTBIO hook with DE unmodified.</t>
				</list>
				<t>Note that given the way the discovery procedure is designed, the implementations installed in the first place have assigned
				the highest implementation index numbers. Usually this has no impact on the design on client software but it is a good thing
				to know it.</t> 
			</section>
		</section>

		<!-- The RAM helper -->
		
		<section anchor="ramhelper" title="The RAM helper">
			<t>Once an API implementation has been discovered, it is easy for client software to invoke the API routines if the API entry point is located
			at page 3 (using direct calls) or in a ROM slot (using inter-slot calls, for example via the BIOS function CALSLT). However, for API implementations
			installed in a mapped RAM segment, it is not so easy to invoke the API entry point. MSX-DOS 2 provides system routines to execute code placed on an arbitrary segment,
			but the client code must still ensure that the appropriate RAM slot is switched on page 1. For MSX-DOS 1 it is even worse, since no mapper
			support routines are provided.</t>
			<t>To solve this issue, and in order to ease the development of client software, this specification includes the concept of the RAM helper. The RAM helper
			consists of a set of routines and a mappers table that are placed at system RAM on page 3, each having an entry point in the same area. Two of the routines allow to easily perform
			inter-segment calls, while the other allows to perform inter-segment data reads.</t>
			<t>To check for the presence of the RAM helper, and to obtain the address of its routines, EXTBIO must be called with DE=#2222, HL=0, and A=#FF.
			If the RAM helper is not installed, then HL=0 at output; otherwise the following register values will be returned:</t>
			<vspace blankLines='1' />
      <list style="empty">
        <t>HL = Address of a jump table in page 3</t>
        <t>BC = Address of a mappers table in page 3</t>
        <t>A  = Number of entries in the jump table</t>
      </list>
      <t>The value returned in A is always 3 as per this specification. This value is provided because future specification versions
      may define additional routines, and so client applications may detect which specification version the installed RAM helper conforms to.</t>
      <t>The jump table routines are as follow:</t>
      <vspace blankLines='1' />
			<list style="empty">
				<t>+0: Call a routine in a mapped RAM segment</t>
				<list style="empty">
					<t>Input:</t>
					<list style="empty">
						<t>IYh = Slot number</t>
						<t>IYl = Segment number</t>
						<t>IX  = Target routine address (must be a page 1 address)</t>
						<t>AF, BC, DE, HL = Parameters for the target routine</t>
					</list>
				</list>
				<list style="empty">
					<t>Output:</t>
					<list style="empty">
						<t>AF, BC, DE, HL, IX, IY = Parameters returned from the target routine</t>
					</list>
				</list>
				<vspace blankLines='1' />
				<t>+3: Read a byte from a RAM segment</t>
				<list style="empty">
					<t>Input:</t>
					<list style="empty">
						<t>A = Slot number</t>
						<t>B = Segment number</t>
						<t>HL = Address to be read from <list style="empty"><t>(higher two bits will be ignored)</t></list></t>
					</list>
				</list>
				<list style="empty">
					<t>Output:</t>
					<list style="empty">
						<t>A = Data readed from the specified address</t>
						<t>F, BC, DE, HL, IX, IY preserved</t>
					</list>
				</list>
				<vspace blankLines='1' />
				<t>+6: Call a routine in a mapped RAM segment, with inline routine identification</t>
				<list style="empty">
					<t>Input:</t>
					<list style="empty">
						<t>AF, BC, DE, HL = Parameters for the target routine</t>
					</list>
				</list>
				<list style="empty">
					<t>Output:</t>
					<list style="empty">
						<t>AF, BC, DE, HL, IX, IY = Parameters returned from the target routine</t>
					</list>
				</list>
				<list style="empty">
					<t>The routine is to be called as follows:</t>
					<list style="empty">
						<t>CALL CALLSEG</t>
						<t/>
						<t>CALLSEG:</t>
						<t>CALL &lt;routine address&gt;</t>
						<t>DB &amp;Bmmeeeeee</t>
						<t>DB &lt;segment number&gt;</t>
						<t>;no RET is needed here</t>
					</list>
          <vspace blankLines='1' />
          <t>where</t>
          <vspace blankLines='1' />
          <list style="empty">
            <t>mm is the mapper slot, as an index (0 to 3) in the mappers table</t>
            <vspace blankLines='1' />
            <t>eeeeee is the routine to be called, as an index (0 to 63) of a jump table that starts at address #4000 of the segment.
            That is, 0 means #4000, 1 means #4003, 2 means #4006, etc.</t>
          </list>
				</list>		
			</list>
      <t>The mappers table is as follows:</t>
      <vspace blankLines='1' />
      <list style="empty">
        <t>+0: Slot number of the primary mapper</t>
        <t>+1: Maximum segment number of the primary mapper</t>
        <t>+2: Slot number of second mapper</t>
        <t>+3: Maximum segment number of the secondary mapper</t>
        <t>...</t>
      </list>
      <t>The table contains from one to four entries depending on how many mappers are present in the system.
      For each mapper, an entry exists containing the slot number and the maximum available segment number (this will be #FE for 4MB mappers, since
      segment #FF can't be used, see <xref target="apirule8"/>). The end of the table is always indicated by a zero byte (even if all four
      entries are filled).
      </t>
      <t>This table is needed when using the routine that calls a routine in a mapped RAM segment with inline routine identification:
      the slot number is specified as an index in this table (from 0 for the first entry, up to 3 for the fourth entry). The maximum available
      segment number is provided to help RAM based implementations to decide in which segment should they be installed; normally they should
      provide the user the option to decide which segment to use, and default to use the maximum segment number available of one of
      the available mappers if the user does not provide any segment number. (Note that this applies when running under MSX-DOS 1 only,
      since MSX-DOS 2 provides its own set of mapper support routines)</t>
			<t>
        The installation code for every API implementation that is to be installed on a mapped RAM segment must check if the RAM helper is installed
        in the system (by using the procedure based on a EXTBIO call described above). If not, the implementation installer has two options:
        either install a RAM helper by itslef, appropriately patching the EXTBIO hook so that the RAM helper can be discovered by using the explained procedure;
        or refuse to install, thus requiring the user to previously install a RAM helper in order to install that implementation.
        This way, client applications can always safely assume that the RAM helper is installed if implementations that reside in
        mapped RAM are installed.
      </t>
			<t>How page 3 RAM is allocated in order to install the RAM helper is outside the scope of this specification.</t>
			<t>Having a RAM helper installed is mandatory when installing API implementations which reside in mapped RAM, but using it is optional; client software may choose
			to use its own code for calling the API routines and reading the API data. However, it is recommended to use the RAM helper since it significantly reduces
			the complexity of client software.</t>
			
			<section anchor="c4010" title="Notes on the routine for calling a routine with inline routine identification">
				<t>
          The routine for calling a routine with inline routine identification is intended for helping in the process of patching hooks
          (mainly the EXTBIO hook) to implementations that do not otherwise need to allocate or modify RAM on page 3. If the implementation has 
          the code for the discovery procedure available at an entry that belongs to a jump table that starts at address #4000
          (the start of the segment where it resides), and saves the previous state of the hook in the segment itself,
          then it is enough to set up the contents of the hook with the five bytes of code needed to call the routine (one CALL and two DB). No further
          action is required on page 3 at install time.</t>
				<t>Note that a double indirection is needed here: a CALL is made to a memory location which in turn contains a CALL to the real routine.
				The implementation of this routine must increase the stack pointer by two, so that execution resumes at the address placed after the first call, ignoring
				whatever is placed after the two DB directives. It is necessary to implement it this way, in order to be able to place a call to this routine in the
				EXTBIO hook, which is just five bytes long.</t>
			</section>
			
		</section>

    <!-- Specificationless applications -->

    <section anchor="specless" title="Specificationless UNAPI applications">
      <t>The UNAPI specification is primarily intended for the development of software that conforms to a given UNAPI compliant API specification.
      However, the infrastructure offered by UNAPI for the implementation and discovery of API implementations may be useful as well to develop
      normal applications that do not follow any standard, but still need to offer services to and be discoverable by the user (typically,
      TSRs, Terminate and Stay Resident programs).</t>

      <t>For this reason, the concept of specificationless UNAPI applications is introduced. Such applications are identical to regular
      UNAPI implementations, except for the following:</t>
      <vspace blankLines='1' />

      <list style="numbers">
        <t>The API identifier is an empty string. That is, when performing the discovery procedure (see <xref target="discovery"/>), a single
          zero byte must be placed by client software in ARG, and this is what the specificationless application discovery code must search for.
          The application is then identified exclusively by the implementation name, which becomes the application name.
        </t>
        <vspace blankLines='1' />
        <t>
          There is no concept of Specification routines vs Implementation-specific routines as defined in <xref target="apirule4"/>.
          Instead, the whole range of function numbers 1-254 are implementation-specific routines, that is, the specificationless
          application may define these routines as desired (or define no routines at all).
          Note however that the API information routine (see <xref target="apirule5"/>) is still mandatory,
          and that function number 255 is still reserved.
        </t>
        <vspace blankLines='1' />
        <t>
          Since specificationless application do not conform to any API specification, the API specification version number
          provided by the API information routine (see <xref target="apirule5"/>) does not make sense. This routine should
          return this value as Version 0.0 (that is, DE=0).
        </t>
      </list>

      <t>Apart from these differences, the whole set of rules enumerated in this document still apply, including 
      the discovery procdedure and the rules that refer to routine registers usage.</t>

      <t>
        Specificationless applications will tipically take the form of TSRs that install on RAM, but this is not mandatory
        and ROM specificationless applications are allowed as well.
      </t>
      
    </section>
    
  </middle>
  
		<!-- Appendixes -->

		<back>
			<section title="Acknowledgements">
				<t>This document was produced using xml2rfc v1.34 (of http://xml.resource.org/) from a source in RFC-2629 XML format.</t>
			</section>
			<section title="Document version history">
			<vspace blankLines='1' />
			<list style="symbols">
        
				<t>Version 0.2</t>
				<list style="symbols">
					<t>Added the "The big picture" section (<xref target="samplescenario" />)</t>
				</list>
				<vspace blankLines='1' />
        
				<t>Version 0.3</t>
				<list style="symbols">
					<t>"The big picture" section (<xref target="samplescenario" />) has been renamed to "Sample scenario"</t>
					<t>Added the routine to call address #4010 in the "The RAM helper" section (<xref target="ramhelper" />)</t>
				</list>
				<vspace blankLines='1' />
				<t>Version 0.4</t>
				<list style="symbols">
					<t>The maximum length for implementation names has been changed from 64 to 63 characters 
					(<xref target="glossary" /> and <xref target="apirule5" />), so a full length name will be 64 bytes long
					including the zero termination byte.</t>
					<t>Slightly modified the explanation of the discovery procedure to make more clear (sort of)
					the fact that the API identifier must be zero-terminated only when it is copied to ARG
					(that is, the zero byte is NOT part of the identifier itself).
					See <xref target="discovery_steps" /> and <xref target="discovery_implement" />.</t>
					<t>Added information about the alternate registers usage in <xref target="apirule3" />.</t>
					<t>Added the "avoid segment #FF" rule (see <xref target="apirule8" />).</t>
					<t>The usage of "#" as hexadecimal prefix is now noted in the glossary (see <xref target="glossary" />).</t>
				</list>
				<vspace blankLines='1' />
        
				<t>Version 1.0</t>
				<list style="symbols">
					<t>Added the rule about routine names (see <xref target="apirule9" />).</t>
				</list>
        <vspace blankLines='1' />

        <t>Version 1.1</t>
        <list style="symbols">
          <t>
            Added the concept of specificationless applications (see <xref target="specless" />).
          </t>
          <t>
            Modified the RAM helper specification (see <xref target="ramhelper" />) so that:
          </t>
          <list style="symbols">
            <t>Installing the RAM helper when it is not installed is now optional (RAM based implementation installers may refuse to install instead).</t>
            <t>When invoking the EXTBIO hook with A=#FF, additional information is returned in registers A and DE.</t>
            <t>The routine for invoking a routine in the segment address #4010 has been replaced by a routine for invoking a routine
            in a jump table of up to 64 entries.</t>
            <t>A mappers table is now generated in addition to the jump table.</t>
          </list>
        </list>

      </list>
			</section>
		</back>
</rfc>