NestorBASIC version 1.11
Автор Nestor Soriano (Konami Man), Декабрь 2004

1. ЧТО ТАКОЕ NESTORBASIC?

NestorBASIC это набор подпрограмм(функций,процедур) в машинном коде,            
интегрированных в один файл, предназначенных для использования в программах, 
написанных на БЕЙСИКе. NestorBASIC обеспечивает, без утраты совместимости с
Turbo-BASIC, следующую функциональность:

- Полный доступ ко всей страничной оперативной памяти компьютера(всей памяти, в 
  случае DOS 1, всей свободной памяти в случае DOS 2), вплоть до 4 Mb.
- Доступ ко всей видеопамяти(VRAM), с возможностью пересылки блоков данных как
  в пределах VRAM, так и между VRAM и RAM.
- Размещение БЕЙСИК-программ в страничной памяти, с возможностью выполнять
  переход из одной программы в другую с сохранением переменных.
- Доступ к файлам на диске и непосредственно к физическим секторам, с
  возможностью чтения/записи напрямую в/из страничной RAM и VRAM. Поиск файлов, 
  работа с директориями.
- Сжатие и распаковка графики.
- Проигрывание Moonblaster-музыки. Подгрузка samplekit'ов.
- Воспроизведение звуковых эффектов на PSG(AY-3-8910).
- Вызов подпрограмм в машинном коде, находящихся в BIOS, SUB-BIOS, в основной
области памяти БЕЙСИКа, рабочей области системы, или в сегменте страничного ОЗУ.
- Вызов функций NestorMan, процедур InterNestor Suite и InterNestor Lite.

Все имеющиеся функции доступны через один единственный USR и массив
целочисленных параметров, следовательно они полностью совместимы с TurboBASIC.
Собственно, сам компилятор TurboBASIC содержится в файле NestorBASIC, и
автоматически загружается при резидентной установке NestorBASIC.

NestorBASIC загружается в сегмент ОЗУ, не используемый BASIC'ом, так что нужен
лишь небольшой объем основной памяти BASIC'a (примерно 500 байт) для программы 
перехода. Остальная основная память BASIC'а свободна для программы на БЕЙСИКе.


2. СИСТЕМНЫЕ ТРЕБОВАНИЯ. ЗАГРУЗКА NESTORBASIC

NestorBASIC работает на любой MSX2/2+/Turbo-R с как минимум 128Кб страничной 
памяти. В случае с DOS 2 нужен хотя бы один свободный сегмент ОЗУ в первичном
маппере (два, если собираетесь использовать проигрыватели музыки. Подробности
см. в разделе 8).

Для загрузки NestorBASIC, просто выполните BLOAD"NBASIC.BIN",R. Ни
предварительных, ни последующих команд CLEAR и DEFUSR не требуется. Если
все прошло без ошибок, мы получаем следующее:

- NestorBASIC и TurboBASIC загружены, каждый в свой сегмент ОЗУ, и готовы к
работе.

- Размер свободной основной памяти BASIC'a уменьшился примерно на 500 байт, 
которые были заняты программой, осуществляющей переход в сегмент NestorBASIC'a.

- Первый USR [USR0(параметр) или просто USR(параметр)] указывает на
вышеупомянутую программу перехода - это обработчик вызовов функций
NestorBASIC.

- Создан целочисленный массив параметров P. Этот массив используется для
передачи параметров в функции NestorBASIC'a и приема из них результатов, за
исключением кодов ошибок. Коды ошибок возвращаются USR-командой (функции для
работы с файлами и функции обработки строк требуют собственный строковый массив,
который нужно объявлять отдельно. Подробности см. в разделе 4). Первые пять
элементов P инициализированы следующим образом:

P(0) = Количество доступных сегментов памяти, или код ошибки
P(1) = Мажорная версия NestorBASIC
P(2) = Минорная версия NestorBASIC, в формате BCD (должна показываться 
       в шестнадцатиричном формате)
P(3) = Мажорная версия MSX-DOS
P(4) = Минорная версия MSX-DOS, в формате BCD (должна показываться 
       в шестнадцатиричном формате)
       
Число доступных сегментов ОЗУ всегда будет как минимум 5. Меньшее значение 
в P(0) будет отражать код ошибки, возникшей при резидентной установке
NestorBASIC'a:

0: Компьютер не имеет страничной памяти, или в нем только 64K страничного ОЗУ.  
1: Дисковая ошибка при чтении NestorBASIC или TurboBASIC из файла NBASIC.BIN.
2: Нет свободных сегментов в первичном маппере. Эта ошибка может появиться
   только под DOS 2.
3: NestorBASIC уже был установлен. Все переменные были проинициализированы.
4: Неопределено в этой версии.

После резидентной загрузки NestorBASIC'a можно резервировать память для других  
резидентных подпрограмм в обычном порядке, т.е. использовать команду CLEAR для
установки начала зарезервированной области. Тем не менее, в связи с тем, что
NestorBASIC производит переключения слотов/сегментов в странице 2, и
интерпретатор БЕЙСИКа располагает стек в области памяти ниже области строковых
переменных и области, зарезервированной для пользователя, есть нижний предел для
адреса, устанавливаемого командой CLEAR. А конкретно, нельзя зарезервировать
память с адреса меньше, чем определяется данной формулой:

&HC000 + (MAXFILES+1)*267 + FRE("") + 100

Также, помните, что команда CLEAR, как и загрузка/очистка/модификация программы
на БЕЙСИКе стирает все переменные. В этом случае, P-массив должен быть
переопределен командой DEFINT P:DIM P(15), и это должно быть сделано вне
турбо-блоков. Также, F-массив должен быть переопределен если требуется
(подробности о массиве F см. в разделе 4). Если нужно объявить F-массив внутри
турбо-блока, необходимо сделать это в первой строке турбо-блока, чтобы
обезопасить использование функций NestorBASIC'а:

10 'save"autoexec.bas"
20 BLOAD"nbasic.bin",R:IF P(0)<5 THEN PRINT "Error!":END
30 CLEAR 100:DEFINT P:DIM P(15)
40 _TURBO ON(P())
50 DIM F$(1) 'See section 4
...
65000 _TURBO OFF
65010 RUN"next.bas"

10 'save"next.bas"
20 DEFINT P:DIM P(15)
30 _TURBO ON(P())
40 DIM F$(0) 'If F$(1) is not needed. See section 4.1
...
65000 _TURBO OFF

Также, помните, что нулевой USR всегда зарезервирован за NestorBASIC'ом, как
служебный вызов. Вызовы с USR1 по USR9 не заняты.

3. ЛОГИЧЕСКИЕ СЕГМЕНТЫ

3.1. ЧТО ТАКОЕ ЛОГИЧЕСКИЙ СЕГМЕНТ?

Страничное ОЗУ компьютеров MSX организовано в сегменты по 16Кб. Каждый слот ОЗУ 
содержит определенное число S сегментов (нумеруемых от 0 до S-1), доступных,
когда они подключены в адресное пространство активного слота памяти, что
контролируется через порты &HFC to &HFF.

При загрузке NestorBASIC'а, все имеющиеся слоты сканируются на наличие ОЗУ (всей
памяти в случае DOS 1, всей свободной памяти в случае DOS 2), и строится таблица
сегментов. В этой таблице, все найденные сегменты записаны в виде пар
слот-сегмент (под DOS 2, сегменты сначала выделяются). NestorBASIC
идентифицирует каждую из этих пар по порядковому номеру в таблице. Этот номер
называется номером логического сегмента, и позволяет пользователю оперировать
всей доступной памятью в последовательном виде, не заботясь ни о номерах слотов,
ни о номерах физических сегментов, в которых она находится.
Например, представим MSX с 128K внутренней RAM (8 сегментов) и маппер на 1024Кб
(64 сегмента) во внешнем слоте. Тогда, после инициализации NestorBASIC'а, в
случае DOS 1, пользователю будет доступно 72 логических сегмента, под номерами
от 0 до 71, и достаточно указать этот номер в соответствующих функциях
NestorBASIC для их использования. Номера физических слотов и сегментов уже не
потребуются.

Адресное пространство логического сегмента (далее - просто "сегмента") от &H0000
до &H3FFF. Если заданы более высокие адреса при вызове функций NestorBASIC, они 
будут преобразованы. Т. е., адреса &H4000-&H7FFF, &H8000-&HBFFF и &HC000-&HFFFF
эквивалентны &H0000-&H3FFF при доступе к сегментам ОЗУ через NestorBASIC.
Все сегменты доступны для чтения и записи, но есть важные ограничения по 
отношению к первым шести:

- Сегмент 0 содержит собственно NestorBASIC, и лишь небольшая область ОЗУ       
остается доступной для пользователя в конце него. Используйте функцию 1 чтобы
получить начальный адрес этой области (описание функции см. в разделе 10).

- Сегмент 1 содержит компилятор TurboBASIC. Можно перезаписать этот сегмент     
только в том случае, если Вы не собираетесь использовать компилятор.

- Сегмент 2 всегда подключен к 2 странице (адреса &H8000 - &HBFFF), и содержит  
исполняемую программу на БЕЙСИКе и часть её переменных.

- Сегмент 3 всегда подключен к странице 3 (addresses &HC000 to &HFFFF), и       
содержит рабочую область системы и часть переменных программы на БЕЙСИКе. Будьте
внимательны при записи сюда.

- Сегмент 4 используется как служебный буфер некоторыми функциями NestorBASIC'а.
Вы можете использовать этот сегмент для ваших данных, если Вы не обращаетесь к
этим функциям NestorBASIC'а. См. раздел 10 или приложение 1 чтобы узнать, какие
функции используют этот сегмент.

- Сегмент 5, если он есть, изначально свободен и не используется NestorBASIC'ом.
Но если используются музыкальные плейеры, при инициализации они занимают этот
сегмент. Подробности см. в разделе 8.

Все остальные имеющиеся сегменты в полном распоряжении программиста.

ВНИМАНИЕ: логические сегменты 2 и 4 поменялись ролями при переходе с версии 0.07
на версию 1.00 NestorBASIC'a. В версии 0.07 и ранее, сегмент 2 был служебным
буфером NestorBASIC, а сегмент 4 соответствовал странице 2.

При использовании функций обмена блоками данных, нужно быть осторожным, чтобы   
сумма адреса назначения и длинны пересылаемого блока не превысила адрес &H3FFF
(например, не пытайтесь переслать &H2000 байт указывая адрес &H3000 как адрес
назначения). В таком случае, сегмент 0 или сегмент 3 будут перезаписаны, и
результат будет непредсказуем.

ВНИМАНИЕ: с помощью функции 80 можно указать NestorBASIC'у зарезервировать      
меньше сегментов памяти, чем суммарно доступно. Это полезно под DOS 2, когда 
одновременно используются другие резидентные программы, требующие выделения
памяти (например, RAM-диск или NestorMan). Описание функций см. в разделе 10.


3.2. ИСПОЛЬЗОВАНИЕ VRAM В КАЧЕСТВЕ ЛОГИЧЕСКИХ СЕГМЕНТОВ

NestorBASIC позволяет использовать VRAM для ваших данных, путем эмуляции        
дополнительных RAM-сегментов. Если NestorBASIC показывает, что располагает S
сегментами памяти, то номера сегментов с 0 по S-1 соотносятся со страничной
RAM, тогда как номера сегментов с S по S+7 (или S+3, в зависимости от объема
видеопамяти, 128Кб или 64Кб) соотносятся с VRAM.

Вернемся к компьютеру из предыдущего примера. После резидентной загрузки        
NestorBASIC'a или после вызова функции 1 (см. список функций) получаем
P(0)=72. Это значит (предполагая, что у нас 128Кб видеопамяти), что сегменты
с 72 по 79 соотносятся с VRAM.

Соответствие между сегментами и адресами VRAM обратное: сегменты с меньшими     
номерами соответствуют наибольшим адресам VRAM. Так сделано для того, чтобы
облегчить задачу программисту при освобождении сегментов VRAM, соответствующих
области отображения: это будет последний сегмент при работе в текстовом режиме
или при использовании лишь одной страницы в графическом режиме.

Обратимся к предыдущему примеру: компьютеру с 72 сегментами RAM и 128K VRAM.    
Если программа работает в текстовом режиме, используются только первые 2000
байт VRAM: это видеоОЗУ соответствует последнему сегменту VRAM, под номером
79. В этом случае, пользовательская программа может свободно использовать
сегменты с 72 по 78, и диапазон доступных сегментов будет 0 - 78, без
необходимости пропускать какой-либо сегмент внутри этой последовательности. 
Если программа работает в SCREEN 5 и использует только графическую страницу 0,
диапазон сегментов будет с 0 по 77; в SCREEN 7 он будет с 0 по 75, и т.д.

Конечно, NestorBASIC также имеет функции для работы с VRAM напрямую, без        
эмуляции в ней сегментов RAM. Эти функции позволяют пересылать данные
VRAM<-->RAM и VRAM<-->файл. 

ВНИМАНИЕ: сегменты VRAM могут использоваться - как и обычные сегменты RAM -     
для размещения данных и программ на БЕЙСИКе, а также для блоковых операций
обмена с диском и сегментами RAM. Но учтите, что сегменты VRAM не могут быть
использованы для:

- Сжатия/распаковки графики
- Исполнения программ в машинном коде
- Исполнения прерываний, определяемых пользователем.
- Воспроизведения звуковых эффектов на PSG(AY-3-8910)
- Воспроизведения музыки

Если Вы попытаетесь использовать сегменты VRAM для какой-то из этих целей,      
функция вернет ошибку "несуществующий сегмент".


3.3. СЕГМЕНТ 255

Логический сегмент 255 имеет особое предназначение. Он соотносится не с         
каким-то конкретным сегментом RAM или VRAM, а с основной памятью BASIC'а, то
есть - c ОЗУ, используемым MSX-BASIC'ом, по адресам &H8000-&HFFFF (к нему, в
отличие от других сегментов, не применяются ни ограничения, ни преобразования 
адресов в диапазон &H0000-&H3FFF). Это удобно использовать для обмена данными 
между каким-либо сегментом и переменной БЕЙСИКа или массивом переменных:

 1 'Copy 10 bytes from segment 7, begin address &H1000,
 2 'to integer array D.
 3 '(See section 10 for detailed functions specification)
 4 '
10 DEFINT D:DIM D(4) '5 integer data = 10 bytes
20 P(0)=7	     'Source segment
30 P(1)=&H1000	     'Source begin address
40 P(2)=255	     'Destination segment=BASIC main RAM
50 P(3)=VARPTR(D(0)) 'Destination begin address=D array
60 P(4)=10	     'length
70 J=USR(10)	     'Call to function 10 (block transfer between segments)


3.4. КАРТА СЕГМЕНТОВ 

Резюмируя данный раздел, предоставим весь список имеющихся сегментов и их       
описание. S - это количество сегментов, возвращаемое в P(0) при резидентной
загрузке NestorBASIC или при вызове функции 1.

0: Сегмент NestorBASIC'а
1: Сегмент Turbo-BASIC'а
2: Основное ОЗУ BASIC'а, страница 2 (&H8000-&HBFFF)
3: Основное ОЗУ BASIC'а, страница 3 (&HC000-&HFFFF)
4: Сегмент служебного буфера
5 по S-1: Память, доступная программе пользователя (if S>5)
   Если загружен музыкальный плейер,
   он находится в сегменте 5. См. раздел 8.
S:   VRAM, адреса &H1C000-&H1FFFF (64K VRAM: &HC000-&HFFFF)
S+1: VRAM, адреса &H18000-&H1BFFF (64K VRAM: &H8000-&HBFFF)
S+2: VRAM, адреса &H14000-&H17FFF (64K VRAM: &H4000-&H7FFF)
S+3: VRAM, адреса &H10000-&H13FFF (64K VRAM: &H0000-&H3FFF)
S+4: VRAM, адреса &H0C000-&H0FFFF (отсутствует при 64K VRAM)
S+5: VRAM, адреса &H08000-&H0BFFF (отсутствует при 64K VRAM)
S+6: VRAM, адреса &H04000-&H07FFF (отсутствует при 64K VRAM)
S+7: VRAM, адреса &H00000-&H03FFF (отсутствует при 64K VRAM)

S+8 to 254: Отсутствуют (если S+8<255)
255: Основная память MSX-BASIC (&H8000-&HFFFF)


3.5.ОШИБКИ

Все функции доступа к RAM и/или VRAM возвращают код ошибки -1, если был указан  
номер отсутствующего сегмента RAM, или была попытка доступа к адресу VRAM выше
&HFFFF в компьютерах с 64K VRAM, или если был указан сегмент VRAM или 255-й
сегмент в функциях, которые поддерживают только обычные RAM-сегменты.

4. ДОСТУП К ДИСКУ

NestorBASIC включает функции для работы с файлами на диске и доступа к другим   
возможностям MSX-DOS, а именно:

* Создание/удаление/переименование/поиск файлов.
* Чтение/запись файлов в/из любого сегмента или области VRAM.
* Чтение/запись секторов в/из любого сегмента или области VRAM.
* Определение емкости диска, свободного пространства.
Функции, доступные только под DOS 2:
* Перемещение файлов, чтение/установка атрибутов файла.
* Получение/изменение текущего рабочий диска/каталога (директории).
* Определение емкости/создание RAM-диска.

4.1. МАССИВ F$

Для передачи имён файлов и директорий, эти функции задействуют массив строковых 
переменных F$. Четыре из них - поиск, переименование и перемещение файлов, а
также обработка пути файлов требуют двух строковых элементов, для чего нужно,
чтобы был объявлен массив F$ из двух элементов [DIM F$(1)]. Остальным функциям
требуется только одна строка; поэтому, если не будет использоваться ни одна из
вышеперечисленных четырех функций, можно объявить массив F$ только из одного
элемента [DIM F$(0)]. Особенно это рекомендуется в случае использования
Turbo-BASIC'а, потому что внутри турбо-блоков каждая строка занимает 256 байт,
независимо от её реальной длины.

Также, нужно иметь в виду, что массив F$ должен объявляться сразу же после
начала турбо-блока, следующей строкой:

1000 _TURBO ON(P())
1010 DIM F$(1) or DIM F$(0)
...
65000 _TURBO OFF

ВАЖНО: Строковые переменные, определенные вне турбо-блока, равно как и другие     
переменные, не передаются в турбо-блок, и восстанавливаются после его завершения
Например:

10 A$="Outside"
20 _TURBO ON
30 A$="Inside":PRINT A$
40 _TURBO OFF
50 PRINT A$
run
Inside
Outside

С NestorBASIC это правило также действует, но со строками F$() требуется          
дополнительная предосторожность. Если массив F$ использовался вне турбо-блока
и будет снова объявляться внутри него, следующая строка должна быть помещена
перед CALL TURBO ON:

F$(0)=F$(0)+"":F$(1)=F$(1)+""

Эта строка не нужна, если не требуется сохранить прежнее состояние F$, или 
если Вы не будете объявлять F$ внутри турбо-блока.
