NestorBASIC version 1.11
Автор Nestor Soriano (Konami Man), Декабрь 2004

1. ЧТО ТАКОЕ NESTORBASIC?

NestorBASIC это набор подпрограмм(функций,процедур) в машинном коде, интегрированных в один файл, 
презназначенных для использования в программах, написанных на MSX-BASIC. NestorBASIC обеспечивает, 
без утраты совместимости с Turbo-BASIC, следующую функциональность:

- Полный доступ ко всей страничной оперативной памяти компьютера(всей памяти, в 
  случае DOS 1, всей свободной памяти в случае DOS 2), вплоть до 4 Mb.
- Доступ ко всей видеопамяти(VRAM), с возможностью пересылки блоков данных как
  в пределах VRAM, так и между VRAM и RAM.
- Размещение БЕЙСИК-программ в страничной памяти, с возможностью выполнять переход
  из одной программы в другую с сохранением переменных.
- Доступ к файлам на диске и непосредственно к физическим секторам, с
  возможностью чтения/записи напрямую в/из страничной RAM и VRAM. Поиск файлов, 
  работа с директориями.
- Сжатие и распаковка графики.
- Проигрывание Moonblaster-музыки. Подгрузка samplekit'ов.
- Воспроизведение звуковых эффектов на PSG(AY-3-8910).
- Вызов подпрограмм в машинном коде, находящихся в BIOS, SUB-BIOS, в основной области
  памяти БЕЙСИКа, рабочей области системы, или в сегменте страничного ОЗУ.
- Вызов функций NestorMan, процедур InterNestor Suite и InterNestor Lite.

Все имеющиеся функции доступны через один единственный USR и массив
целочисленных параметров, следовательно они полностью совместимы с TurboBASIC.
Собственно, сам компилятор TurboBASIC содержится в файле NestorBASIC, и
автоматически загружается при резидентной установке NestorBASIC.

NestorBASIC загружается в сегмент ОЗУ, не используемый БЕЙСИКом, так что нужен
лишь небольшой объем основной памяти BASIC'a (примерно 500 байт) для программы 
перехода. Остальная основная память BASIC'а свободна для программы на БЕЙСИКе.


2. СИСТЕМНЫЕ ТРЕБОВАНИЯ. ЗАГРУЗКА NESTORBASIC

NestorBASIC работает на любой MSX2/2+/Turbo-R с как минимум 128Кб страничной 
памяти. В случае с DOS 2 нужен хотя бы один свободный сегмент ОЗУ в первичном
маппере (два, если собираетесь использовать проигрыватели музыки. См. секцию 8 
для подробностей).

Для загрузки NestorBASIC, просто выполните BLOAD"NBASIC.BIN",R. Ни
предварительных, ни последующих команд CLEAR и DEFUSR не требуется. Если
все прошло без ошибок, мы получаем следующее:

- NestorBASIC и TurboBASIC загружены, каждый в свой сегмент ОЗУ, и готовы к
работе.

- Размер свободной основной памяти BASIC'a уменьшился примерно на 500 байт, 
которые были заняты программой, осуществляющей переход в сегмент NestorBASIC'a.

- Первый USR [USR0(параметр) или просто USR(параметр)] указывает на
вышеупомянутую программу перехода. Это обработчик вектора вызова функций
NestorBASIC.

- Создан целочисленный массив параметров P. Этот массив используется для
передачи параметров в функции NestorBASIC'a и приема из них результатов, за
исключением кодов ошибок. Коды ошибок возвращаются USR-командой (функции для
работы с файлами и функции обработки строк требуют собственный строковый массив,
который нужно объявлять отдельно. См. секцию 4 для подробностей). Первые пять
элементов P инициализированы следующим образом:

P(0) = Количество доступных сегментов памяти, или код ошибки
P(1) = Мажорная версия NestorBASIC
P(2) = Минорная версия NestorBASIC, в формате BCD (должна показываться 
       в шестнадцатиричном формате)
P(3) = Мажорная версия MSX-DOS
P(4) = Минорная версия MSX-DOS, в формате BCD (должна показываться 
       в шестнадцатиричном формате)
       
Число доступных сегментов ОЗУ всегда будет как минимум 5. Меньшее значение 
в P(0) будет отражать код ошибки, возникшей при резидентной установке
NestorBASIC'a:

0: Компьютер не имеет страничной памяти, или в нем только 64K страничного ОЗУ.
1: Дисковая ошибка при чтении NestorBASIC или TurboBASIC из файла NBASIC.BIN.
2: Нет свободных сегментов в первичном маппере. Эта ошибка может появиться только
   под DOS 2.
3: NestorBASIC уже был установлен. Все переменные были проинициализированы.
4: Неопределено в этой версии.

После резидентной загрузки NestorBASIC'a можно резервировать память для других
резидентных подпрограмм в обычном порядке, т. е. использовать команду CLEAR для
установки начала зарезервированной области.
Тем не менее, в связи с тем, что NestorBASIC производит переключения
слотов/сегментов в странице 2, и интерпретатор БЕЙСИКа располагает стек в области
памяти ниже области строковых переменных и области, зарезервированной для
пользователя, есть нижний предел для адреса, устанавливаемого командой CLEAR.
А конкретно, нельзя зарезервировать память с адреса меньше, чем определяется
данной формулой:

&HC000 + (MAXFILES+1)*267 + FRE("") + 100

Также, помните, что команда CLEAR, как и загрузка/очистка/модификация программы
на БЕЙСИКе стирает все переменные. В этом случае, P-массив должен быть
переопределен командой DEFINT P:DIM P(15), и это должно быть сделано вне
турбо-блоков. Также, F-массив должен быть переопределен если требуется (см.
секцию 4 для подробностей о массиве F). Если нужно объявить F-массив внутри
турбо-блока, необходимо сделать это в первой строке турбо-блока, чтобы
обезопасить использование функций NestorBASIC'а:

10 'save"autoexec.bas"
20 BLOAD"nbasic.bin",R:IF P(0)<5 THEN PRINT "Error!":END
30 CLEAR 100:DEFINT P:DIM P(15)
40 _TURBO ON(P())
50 DIM F$(1) 'See section 4
...
65000 _TURBO OFF
65010 RUN"next.bas"

10 'save"next.bas"
20 DEFINT P:DIM P(15)
30 _TURBO ON(P())
40 DIM F$(0) 'If F$(1) is not needed. See section 4.1
...
65000 _TURBO OFF

Также, помните, что нулевой USR всегда зарезервирован за NestorBASIC'ом как
вектор вызовов. Векторы с USR1 по USR9 не заняты.

3. ЛОГИЧЕСКИЕ СЕГМЕНТЫ

3.1. ЧТО ТАКОЕ ЛОГИЧЕСКИЙ СЕГМЕНТ?

Страничное ОЗУ компьютеров MSX организовано в сегменты по 16Кб. Каждый слот ОЗУ 
содержит определенное число S сегментов (нумеруемых от 0 до S-1), доступных, когда 
они подключены в адресное пространство активного слота памяти, что
контролируется через порты &HFC to &HFF.

При загрузке NestorBASIC'а, все имеющиеся слоты сканируются на наличие ОЗУ (всей
памяти в случае DOS 1, всей свободной памяти в случае DOS 2), и строится таблица
сегментов. В этой таблице, все найденные сегменты регистрируются в пары
слот-сегмент (под DOS 2, сегменты сначала выделяются). NestorBASIC идентифицирует 
каждую из этих пар по порядковому номеру в таблице. Этот номер называется номером 
логического сегмента, и позволяет пользователю оперировать всей доступной памятью  
в последовательном виде, не заботясь ни о номерах слотов, ни о номерах физических
сегментов, в которых она находится.
Например, представим MSX с 128K внутренней RAM (8 сегментов) и маппер на 1024Кб
(64 сегмента) во внешнем слоте. Тогда, после инициализации NestorBASIC'а, в случае
DOS 1, пользователю будет доступно 72 логических сегмента, под номерами от 0 до 71,
и достаточно указать этот номер в соответствующих функциях NestorBASIC для их
использования. Номера физических слотов и сегментов уже не потребуются.

Адресное пространство логического сегмента (далее - просто "сегмента") от &H0000 
до &H3FFF. Если заданы более высокие адреса при вызове функций NestorBASIC, они 
будут преобразованы. То есть, адреса &H4000-&H7FFF, &H8000-&HBFFF и &HC000-&HFFFF
эквивалентны &H0000-&H3FFF при доступе к сегментам ОЗУ через NestorBASIC.
Все сегменты доступны для чтения и записи, но есть важные ограничения по 
отношению к первым шести:

- Сегмент 0 содержит собственно NestorBASIC, и лишь небольшая область ОЗУ 
остается доступной для пользователя в конце него. Используйте функцию 1 чтобы 
получить начальный адрес этой области (описание функции см. в секции 10).

- Сегмент 1 содержит компилятор TurboBASIC. Можно перезаписать этот сегмент
только в том случае, если Вы не собираетесь использовать компилятор.

- Сегмент 2 всегда подключен к 2 странице (адреса &H8000 - &HBFFF), и содержит
исполняемую программу на БЕЙСИКе и часть её переменных.

- Сегмент 3 всегда подключен к странице 3 (addresses &HC000 to &HFFFF), и 
содержит рабочую область системы и часть переменных программы на БЕЙСИКе. Будьте 
внимательны при записи сюда.

- Сегмент 4 используется как служебный буфер некоторыми функциями NestorBASIC'а.
Вы можете использовать этот сегмент для ваших данных, если Вы не обращаетесь к этим
функциям NestorBASIC'а. См. секцию 10 или приложение 1 чтобы узнать, какие функции 
используют этот сегмент.

- Сегмент 5, если он есть, изначально свободен, и не используется NestorBASIC'ом. 
Но если используются музыкальные плейеры, при инициализации они занимают этот сегмент.
См. секцию 8 для подробностей.

Все остальные имеющиеся сегменты в полном распоряжении программиста.

Внимание: логические сегменты 2 и 4 поменялись ролями при переходе с версии 0.07
на версию 1.00 NestorBASIC'a. В версии 0.07 и ранее, сегмент 2 был служебным буфером
NestorBASIC, а сегмент 4 соответствовал странице 2.

При использовании функций обмена блоками данных, нужно быть осторожным, чтобы 
сумма адреса назначения и длинны пересылаемого блока не превысила адрес &H3FFF 
(например, не пытайтесь переслать &H2000 байт указывая адрес &H3000 как адрес
назначения). В таком случае, сегмент 0 или сегмент 3 будут перезаписаны, и
результат будет непредсказуем.

Внимание: с помощью функции 80 можно указать NestorBASIC'у зарезервировать меньше 
сегментов памяти, чем суммарно доступно. Это полезно под DOS 2, когда одновременно
используются другие резидентные программы, требующие выделения памяти (например,
RAM disk или NestorMan). Описание функций см. в секции 10.


3.2. ИСПОЛЬЗОВАНИЕ VRAM ДЛЯ ЛОГИЧЕСКИХ СЕГМЕНТОВ

NestorBASIC позволяет использовать VRAM для ваших данных, путем эмуляции
дополнительных RAM-сегментов. Если NestorBASIC показывает, что располагает S
сегментами памяти, то номера сегментов с 0 по S-1 соотносятся со страничной RAM, тогда как
номера сегментов с S по S+7 (или S+3, в зависимости от объема видепамяти, 128Кб или
64Кб) соотносятся с VRAM.

Вернемся к компьютеру из предыдущего примера. После резидентной загрузки NestorBASIC'a или
после вызова функции 1 (см. список функций) получаем P(0)=72. Это значит (предполагая, что
у нас 128Кб видеопамяти), что сегменты с 72 по 79 соотносятся с VRAM.

Соответствие между сегментами и адресами VRAM обратное: сегменты с меньшими номерами 
соответствуют наибольшим адресам VRAM. Это сделано таким так для того, чтобы помочь
программисту при освобождении сегментов VRAM, соответствующих области отображения:
эти сегменты будут последними при работе в текстовом режиме или при использовании лишь
одной страницы в графическом режиме.
