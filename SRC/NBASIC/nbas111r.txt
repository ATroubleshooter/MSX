NestorBASIC version 1.11
Автор Nestor Soriano (Konami Man), Декабрь 2004

1. ЧТО ТАКОЕ NESTORBASIC?

NestorBASIC это набор подпрограмм(функций,процедур) в машинном коде,            
интегрированных в один файл, предназначенных для использования в программах, 
написанных на MSX-BASIC. NestorBASIC обеспечивает, без утраты совместимости с
X-BASIC, следующую функциональность:

- Полный доступ ко всей страничной оперативной памяти компьютера(всей памяти, в 
  случае DOS 1, всей свободной памяти в случае DOS 2), вплоть до 4 Mb.
- Доступ ко всей видеопамяти(VRAM), с возможностью пересылки блоков данных как
  в пределах VRAM, так и между VRAM и RAM.
- Размещение программ на Бейсике в страничной памяти, с возможностью выполнять
  переход из одной программы в другую с сохранением переменных.
- Доступ к файлам на диске и непосредственно к физическим секторам, с
  возможностью чтения/записи напрямую в/из страничной RAM и VRAM. Поиск файлов, 
  работа с директориями.
- Сжатие и распаковка графики.
- Проигрывание Moonblaster-музыки. Подгрузка samplekit'ов.
- Воспроизведение звуковых эффектов на PSG(AY-3-8910).
- Вызов подпрограмм в машинном коде, находящихся в BIOS, SUB-BIOS, в основной
области памяти BASIC'а, рабочей области системы, или в сегменте страничного ОЗУ.
- Вызов функций NestorMan, процедур InterNestor Suite и InterNestor Lite.

Все имеющиеся функции доступны через один единственный USR и массив
целочисленных параметров, следовательно они полностью совместимы с X-BASIC.
Собственно, сам компилятор X-BASIC содержится в файле NestorBASIC, и
автоматически загружается при резидентной установке NestorBASIC.

NestorBASIC загружается в сегмент ОЗУ, не используемый BASIC'ом, так что нужен
лишь небольшой объем основной памяти MSX-BASIC (около 500 байт) для программы
перехода. Остальная основная память BASIC'а свободна для программы на Бейсике.


2. СИСТЕМНЫЕ ТРЕБОВАНИЯ. ЗАГРУЗКА NESTORBASIC

NestorBASIC работает на любой MSX2/2+/Turbo-R с как минимум 128Кб страничной 
памяти. В случае с DOS 2 нужен хотя бы один свободный сегмент ОЗУ в первичном
маппере (два, если собираетесь использовать музыкальные плееры. Подробности
см. в разделе 8).

Для загрузки NestorBASIC, просто выполните BLOAD"NBASIC.BIN",R. Ни              
предварительных, ни последующих команд CLEAR и DEFUSR не требуется. Если
все прошло без ошибок, мы получаем следующее:

- NestorBASIC и X-BASIC загружены, каждый в свой сегмент ОЗУ, и готовы к        
работе.

- Размер свободной основной памяти MSX-BASIC уменьшился примерно на 500 байт,   
которые были заняты программой, осуществляющей переход в сегмент NestorBASIC'a.

- Первый USR [USR0(параметр) или просто USR(параметр)] указывает на
вышеупомянутую программу перехода - это обработчик вызовов функций
NestorBASIC.

- Создан целочисленный массив параметров P. Этот массив используется для        
передачи параметров в функции NestorBASIC'a и возврата из них результатов, за
исключением кодов ошибок. Коды ошибок возвращаются USR-командой (функции для
работы с файлами и функции обработки строк требуют собственный строковый массив,
который нужно объявлять отдельно. Подробности см. в разделе 4). Первые пять
элементов P инициализированы следующим образом:

P(0) = Количество доступных сегментов памяти, или код ошибки                    
P(1) = Мажорная версия NestorBASIC
P(2) = Минорная версия NestorBASIC, в формате BCD (должна показываться 
       в шестнадцатиричном формате)
P(3) = Мажорная версия MSX-DOS
P(4) = Минорная версия MSX-DOS, в формате BCD (должна показываться 
       в шестнадцатиричном формате)
       
Число доступных сегментов ОЗУ всегда будет как минимум 5. Меньшее значение      
в P(0) будет отражать код ошибки, возникшей при резидентной установке
NestorBASIC'a:

0: Компьютер не имеет страничной памяти, или в нем только 64K страничного ОЗУ.  
1: Дисковая ошибка при чтении NestorBASIC или X-BASIC из файла NBASIC.BIN.
2: Нет свободных сегментов в первичном маппере. Эта ошибка может появиться
   только под DOS 2.
3: NestorBASIC уже установлен. Все переменные были переинициализированы.
4: Неопределено в этой версии.

После резидентной загрузки NestorBASIC'a можно резервировать память для других  
резидентных подпрограмм в обычном порядке, т.е. использовать команду CLEAR для
установки начала зарезервированной области. Тем не менее, в связи с тем, что
NestorBASIC производит переключения слотов/сегментов в странице 2, и
интерпретатор MSX-BASIC располагает стек в области памяти ниже области строковых
переменных и области, зарезервированной для пользователя, есть нижний предел для
адреса, устанавливаемого командой CLEAR. А конкретно, нельзя зарезервировать
память с адреса меньше, чем определяется данной формулой:

&HC000 + (MAXFILES+1)*267 + FRE("") + 100

Также, помните, что команда CLEAR, как и загрузка/очистка/модификация программы 
на Бейсике стирает все переменные. В этом случае, P-массив должен быть
переопределен командой DEFINT P:DIM P(15), и это должно быть сделано вне блоков
компиляции (турбо-блоков). Также, должен быть переопределен F–массив, если
требуется (подробности о массиве F см. в разделе 4). Если нужно объявить
F-массив внутри турбо-блока, необходимо сделать это в первой строке
турбо-блока, чтобы обезопасить использование функций NestorBASIC'а:

10 'save"autoexec.bas"
20 BLOAD"nbasic.bin",R:IF P(0)<5 THEN PRINT "Error!":END
30 CLEAR 100:DEFINT P:DIM P(15)
40 _TURBO ON(P())
50 DIM F$(1) 'See section 4
...
65000 _TURBO OFF
65010 RUN"next.bas"

10 'save"next.bas"
20 DEFINT P:DIM P(15)
30 _TURBO ON(P())
40 DIM F$(0) 'If F$(1) is not needed. See section 4.1
...
65000 _TURBO OFF

Также, помните, что нулевой USR всегда зарезервирован за NestorBASIC'ом, как    
служебный вызов. Вызовы с USR1 по USR9 не заняты.

3. ЛОГИЧЕСКИЕ СЕГМЕНТЫ

3.1. ЧТО ТАКОЕ ЛОГИЧЕСКИЙ СЕГМЕНТ?

Страничное ОЗУ компьютеров MSX организовано в сегменты по 16Кб. Каждый слот ОЗУ 
содержит определенное число S сегментов (нумеруемых от 0 до S-1), доступных,
когда они подключены в адресное пространство активного слота памяти, что
контролируется через порты &HFC to &HFF.

При загрузке NestorBASIC'а, все имеющиеся слоты сканируются на наличие ОЗУ (всей
памяти в случае DOS 1, всей свободной памяти в случае DOS 2), и строится таблица
сегментов. В этой таблице, все найденные сегменты записаны в виде пар
слот-сегмент (под DOS 2, сегменты сначала выделяются). NestorBASIC
идентифицирует каждую из этих пар по порядковому номеру в таблице. Этот номер
называется номером логического сегмента, и позволяет пользователю оперировать
всей доступной памятью в последовательном виде, не заботясь ни о номерах слотов,
ни о номерах физических сегментов, в которых она находится.
Например, представим MSX с 128K внутренней RAM (8 сегментов) и маппер на 1024Кб
(64 сегмента) во внешнем слоте. Тогда, после инициализации NestorBASIC'а, в
случае DOS 1, пользователю будет доступно 72 логических сегмента, под номерами
от 0 до 71, и достаточно указать этот номер в соответствующих функциях
NestorBASIC для их использования. Номера физических слотов и сегментов уже не
потребуются.

Адресное пространство логического сегмента (далее - просто "сегмента") от &H0000
до &H3FFF. Если заданы более высокие адреса при вызове функций NestorBASIC, они 
будут преобразованы. Т. е., адреса &H4000-&H7FFF, &H8000-&HBFFF и &HC000-&HFFFF
эквивалентны &H0000-&H3FFF при доступе к сегментам ОЗУ через NestorBASIC.
Все сегменты доступны для чтения и записи, но есть важные ограничения по 
отношению к первым шести:

- Сегмент 0 содержит собственно NestorBASIC, и лишь небольшая область ОЗУ       
остается доступной для пользователя в конце него. Используйте функцию 1 чтобы
получить начальный адрес этой области (описание функции см. в разделе 10).

- Сегмент 1 содержит компилятор X-BASIC. Можно перезаписать этот сегмент        
только в том случае, если Вы не собираетесь использовать компилятор.

- Сегмент 2 всегда подключен к 2 странице (адреса &H8000 - &HBFFF), и содержит  
исполняемую программу на Бейсике и часть её переменных.

- Сегмент 3 всегда подключен к странице 3 (addresses &HC000 to &HFFFF), и       
содержит рабочую область системы и часть переменных программы на Бейсике. Будьте
внимательны при записи сюда.

- Сегмент 4 используется как служебный буфер некоторыми функциями NestorBASIC'а.
Вы можете использовать этот сегмент для ваших данных, если Вы не обращаетесь к
этим функциям NestorBASIC'а. См. раздел 10 или приложение 1 чтобы узнать, какие
функции используют этот сегмент.

- Сегмент 5, если он есть, изначально свободен и не используется NestorBASIC'ом.
Но если используются музыкальные плееры, при инициализации они занимают этот
сегмент. Подробности см. в разделе 8.

Все оставшиеся сегменты - в полном распоряжении программиста.

ВНИМАНИЕ: логические сегменты 2 и 4 поменялись ролями при переходе с версии 0.07
на версию 1.00 NestorBASIC'a. В версии 0.07 и ранее, сегмент 2 был служебным
буфером NestorBASIC, а сегмент 4 соответствовал странице 2.

При использовании функций обмена блоками данных, нужно быть осторожным, чтобы   
сумма адреса назначения и длинны пересылаемого блока не превысила адрес &H3FFF
(например, не пытайтесь переслать &H2000 байт указывая адрес &H3000 как адрес
назначения). В таком случае, сегмент 0 или сегмент 3 будут перезаписаны, и
результат будет непредсказуем.

ВНИМАНИЕ: с помощью функции 80 можно указать NestorBASIC'у зарезервировать      
меньше сегментов памяти, чем суммарно доступно. Это полезно под DOS 2, когда 
одновременно используются другие резидентные программы, требующие выделения
памяти (например, RAM-диск или NestorMan). Описание функций см. в разделе 10.


3.2. ИСПОЛЬЗОВАНИЕ VRAM В КАЧЕСТВЕ ЛОГИЧЕСКИХ СЕГМЕНТОВ

NestorBASIC позволяет использовать VRAM для ваших данных, путем эмуляции        
дополнительных RAM-сегментов. Если NestorBASIC показывает, что располагает S
сегментами памяти, то номера сегментов с 0 по S-1 соотносятся со страничной
RAM, тогда как номера сегментов с S по S+7 (или S+3, в зависимости от объема
видеопамяти, 128Кб или 64Кб) соотносятся с VRAM.

Вернемся к компьютеру из предыдущего примера. После резидентной загрузки        
NestorBASIC'a или после вызова функции 1 (см. список функций) получаем
P(0)=72. Это значит (предполагая, что у нас 128Кб видеопамяти), что сегменты
с 72 по 79 соотносятся с VRAM.

Соответствие между сегментами и адресами VRAM обратное: сегменты с меньшими     
номерами соответствуют наибольшим адресам VRAM. Так сделано для того, чтобы
облегчить задачу программисту при освобождении сегментов VRAM, соответствующих
области отображения: это будет последний сегмент при работе в текстовом режиме
или при использовании лишь одной страницы в графическом режиме.

Обратимся к предыдущему примеру: компьютеру с 72 сегментами RAM и 128K VRAM.    
Если программа работает в текстовом режиме, используются только первые 2000
байт VRAM: это видеоОЗУ соответствует последнему сегменту VRAM, под номером
79. В этом случае, пользовательская программа может свободно использовать
сегменты с 72 по 78, и диапазон доступных сегментов будет 0 - 78, без
необходимости пропускать какой-либо сегмент внутри этой последовательности. 
Если программа работает в SCREEN 5 и использует только графическую страницу 0,
диапазон сегментов будет с 0 по 77; в SCREEN 7 он будет с 0 по 75, и т.д.

Конечно, NestorBASIC также имеет функции для работы с VRAM напрямую, без        
эмуляции в ней сегментов RAM. Эти функции позволяют пересылать данные
VRAM<-->RAM и VRAM<-->файл. 

ВНИМАНИЕ: сегменты VRAM могут использоваться - как и обычные сегменты RAM -     
для размещения данных и программ на Бейсике, а также для блоковых операций
обмена с диском и сегментами RAM. Но учтите, что сегменты VRAM не могут быть
использованы для:

- Сжатия/распаковки графики
- Исполнения программ в машинном коде
- Исполнения прерываний, определяемых пользователем.
- Воспроизведения звуковых эффектов на PSG(AY-3-8910)
- Воспроизведения музыки

Если Вы попытаетесь использовать сегменты VRAM для какой-то из этих целей,      
функция вернет ошибку "несуществующий сегмент".


3.3. СЕГМЕНТ 255

Логический сегмент 255 имеет особое предназначение. Он соотносится не с         
каким-то конкретным сегментом RAM или VRAM, а с основной памятью MSX-BASIC'а,
то есть - c ОЗУ, используемым MSX-BASIC'ом, по адресам &H8000-&HFFFF (к нему, в
отличие от других сегментов, не применяются ни ограничения, ни преобразования 
адресов в диапазон &H0000-&H3FFF). Это удобно использовать для обмена данными 
между каким-либо сегментом и переменной Бейсика или массивом переменных:

 1 'Copy 10 bytes from segment 7, begin address &H1000,
 2 'to integer array D.
 3 '(See section 10 for detailed functions specification)
 4 '
10 DEFINT D:DIM D(4) '5 integer data = 10 bytes
20 P(0)=7	           'Source segment
30 P(1)=&H1000	     'Source begin address
40 P(2)=255	         'Destination segment=MSX-BASIC main RAM
50 P(3)=VARPTR(D(0)) 'Destination begin address=D array
60 P(4)=10	         'length
70 J=USR(10)	       'Call to function 10 (block transfer between segments)


3.4. КАРТА СЕГМЕНТОВ 

Резюмируя данный раздел, предоставим весь список имеющихся сегментов и их       
описание. S - это количество сегментов, возвращаемое в P(0) при резидентной
загрузке NestorBASIC или при вызове функции 1.

0: Сегмент NestorBASIC'а
1: Сегмент X-BASIC'а
2: Основное ОЗУ MSX-BASIC'а, страница 2 (&H8000-&HBFFF)
3: Основное ОЗУ MSX-BASIC'а, страница 3 (&HC000-&HFFFF)
4: Сегмент служебного буфера
5 по S-1: Память, доступная программе пользователя (if S>5)
   Если загружен музыкальный плеер,
   он находится в сегменте 5. См. раздел 8.
S:   VRAM, адреса &H1C000-&H1FFFF (64K VRAM: &HC000-&HFFFF)
S+1: VRAM, адреса &H18000-&H1BFFF (64K VRAM: &H8000-&HBFFF)
S+2: VRAM, адреса &H14000-&H17FFF (64K VRAM: &H4000-&H7FFF)
S+3: VRAM, адреса &H10000-&H13FFF (64K VRAM: &H0000-&H3FFF)
S+4: VRAM, адреса &H0C000-&H0FFFF (отсутствует при 64K VRAM)
S+5: VRAM, адреса &H08000-&H0BFFF (отсутствует при 64K VRAM)
S+6: VRAM, адреса &H04000-&H07FFF (отсутствует при 64K VRAM)
S+7: VRAM, адреса &H00000-&H03FFF (отсутствует при 64K VRAM)

S+8 to 254: Отсутствуют (если S+8<255)
255: Основная память MSX-BASIC (&H8000-&HFFFF)


3.5.ОШИБКИ

Все функции доступа к RAM и/или VRAM возвращают код ошибки -1, если был указан  
номер отсутствующего сегмента RAM, или была попытка доступа к адресу VRAM выше
&HFFFF в компьютерах с 64K VRAM, или если был указан сегмент VRAM или 255-й
сегмент в функциях, которые поддерживают только обычные RAM-сегменты.

4. ДОСТУП К ДИСКУ

NestorBASIC включает функции для работы с файлами на диске и доступа к другим   
возможностям MSX-DOS, а именно:

* Создание/удаление/переименование/поиск файлов.
* Чтение/запись файлов в/из любого сегмента или области VRAM.
* Чтение/запись секторов в/из любого сегмента или области VRAM.
* Определение емкости диска, свободного пространства.
Функции, доступные только под DOS 2:
* Перемещение файлов, чтение/установка атрибутов файла.
* Получение/изменение текущего рабочий диска/каталога (директории).
* Определение емкости/создание RAM-диска.

4.1. МАССИВ F$

Для передачи имён файлов и директорий, эти функции задействуют массив строковых 
переменных F$. Четыре из них - поиск, переименование и перемещение файлов, а
также обработка пути файлов требуют двух строковых элементов, для чего нужно,
чтобы был объявлен массив F$ из двух элементов [DIM F$(1)]. Остальным функциям
требуется только одна строка; поэтому, если не будет использоваться ни одна из
вышеперечисленных четырех функций, можно объявить массив F$ только из одного
элемента [DIM F$(0)]. Особенно это рекомендуется в случае использования
Turbo-BASIC'а, потому что внутри турбо-блоков каждая строка занимает 256 байт,
независимо от её реальной длины.

Также, нужно иметь в виду, что массив F$ должен объявляться сразу же после
начала турбо-блока, следующей строкой:

1000 _TURBO ON(P())
1010 DIM F$(1) или DIM F$(0)
...
65000 _TURBO OFF

ВАЖНО: Строковые переменные, определенные вне турбо-блока, равно как и другие   
переменные, не передаются в турбо-блок, и восстанавливаются после его завершения
Например:

10 A$="Outside"
20 _TURBO ON
30 A$="Inside":PRINT A$
40 _TURBO OFF
50 PRINT A$
run
Inside
Outside

С NestorBASIC это правило по-прежнему верно, но со строками F$() требуется      
дополнительная предосторожность. Если массив F$ использовался вне турбо-блока
и будет затем объявляться внутри него - следующая строка должна быть помещена
перед CALL TURBO ON:

F$(0)=F$(0)+"":F$(1)=F$(1)+""

Эта строка не нужна, если не требуется сохранять прежнее состояние F$, или      
если Вы не будете объявлять F$ внутри турбо-блока.

Ещё одно ограничение F$(0) и F$(1) - их длина ограничена 80 символами; остальные
символы будут просто отброшены функциями NestorBASIC'а, которым эти строки
поданы в качестве входных параметров. Все эти ограничения не действуют для
индексов выше чем 1, если в массиве F$ больше элементов; то есть, Вы можете
объявить F$ из более чем двух элементов, и использовать элементы F$(2), F$(3)...
как обычно.

4.2. ОШИБКИ

Помимо ошибки -1, описанной в разделе 3, функции работы с диском имеют          
собственные коды ошибок.

Следующие ошибки могут появиться только под DOS 1:

1: Единый код ошибки MSX-DOS 1. Он может быть вызван следующими причинами:      

   - Файл не найден.
   - Неверное имя файла.
   - Файл уже существует (при переименовании).
   - Неверное имя диска (когда в составе пути файла).
   - Достигнут конец файла при чтении из файла.
   - Диск полон.
   - Корневая директория полна.
   - Функция не доступна под DOS 1.
   
   Под DOS 2, каждая из вышеперечисленных ошибок имеет свой собственный код,    
   никогда не равный 1.

2: Неверный номер файла (нет открытых файлов с таким номером).                  
3: Слишком много открытых файлов. Максимальное число одновременно открытых
файлов можно узнать посредством функции 1.

Следующие ошибки одинаковы под DOS 1 и DOS 2, и имеют те же коды ошибок,        
что и их эквиваленты в MSX-BASIC:

60: Неисправная FAT.
62: Неверный диск (при изменении рабочего диска).
68: Диск защищен от записи.
69: Физическая ошибка диска.
70: Диск отсутствует.

Специфичные для DOS 2 ошибки:

222: Не достаточно свободной памяти для создания RAM-диска для открытия файла.  
219: Неверный диск (будучи частью пути или имени файла).
218: Неправильное имя файла.
217: Неправильный путь.
215: Файл не найден.
214: Каталог (директория) не найден.
213: Корневая директория заполнена.
212: Диск заполнен.
211: Файл уже существует (при переименовании или перемещении файла).
210: Некорректная операция перемещения директорий (каталог не может быть
перемещён в один из своих подкаталогов).
209: Файл только для чтения (при попытке записи в файл).
208: Каталог не пуст (при попытке удаления каталога).
207: Некорректные атрибуты (при установке атрибутов файла/директории).
206: Некорректная операция с "." или ".."
205: Существует системный файл с таким именем(при создании файла,
любой существующий файл с таким именем автоматически удаляется, 
если только у него не установлен атрибут "системный").
204: Директория с таким именем уже существует (аналогично случаю с системными
файлами).
203: Файл с таким именем уже существует (при создании каталога).
202: Файл открыт (при удалении, переименовании или перемещении файла, или
при изменении атрибутов с прямым указанием имени файла).
199: Достигнут конец файла (при чтении из файла).
196: Слишком много открытых файлов (при открытии файла).
195: Неправильный номер файла (больше 63).
194: Неверный номер файла (не принадлежит ни одному открытому файлу).
188: RAM-диск уже существует (при создании RAM-диска).
187: RAM-диск не существует (при удалении RAM-диска).

5. СЖАТИЕ И РАСПАКОВКА ГРАФИКИ

NestorBASIC включает функции для сжатия графических данных из VRAM в RAM,       
и распаковки из RAM в VRAM. Формат сжатия тот же самый, что используется
в процедуре вывода логотипа Sunrise, он работает по-байтно по следующему
принципу:

- Неповторяющиеся байты (до 63):

  &B00nnnnnn &Hdd .. &Hdd

  &Bnnnnnn это количество байт, &Hdd это сами байты

- Повторяющиеся байты (до 63 раз):

  &B01nnnnnn &Hdd

  &Bnnnnnn это количество повторений байта, &Hdd повторяемый байт

- Повторяющийся байт (до 16383 раз):

  &B10nnnnnn &Bnnnnnnnn &Hdd

  &Bnnnnnnnnnnnnnn количество повторений байта, &Hdd повторяемый байт

- Маркер окончания данных:

  &B11000000 = &HC0

(Де)компрессия осуществляется в последовательные сегменты; то есть, после       
(де)компресии из/в адреса &H3FFF сегмента S, процесс продолжается с адреса 
&H0000 сегмента S+1.

5.1 ОШИБКИ

Функции компрессии/декомпрессии графики могут возвращать следующие коды ошибок: 

-1: Ошибка при сжатии или распаковке. Задан несуществующий сегмент, сегмент VRAM
 или 255-й. Также, эта ошибка появляется при указании некорректного адреса VRAM в
 любом из входных параметров.
 5: Ошибка при упаковке. Недостаточно сегментов для сжатия всего изображения.
 6: Ошибка при распаковке. Найдены некорректные данные, или закончились
 сегменты, прежде чем встретился маркер окончания данных.
 
6. РАЗМЕЩЕНИЕ ПРОГРАММ НА БЕЙСИКЕ В ОЗУ И ИХ ЗАПУСК

NestorBASIC включает функции, которые позволяют Вам помещать программы на BASIC 
в любой сегмент RAM или VRAM, актуализировать или запускать их, не теряя переменные
исходной программы (из которой произведен переход в новую).

ВНИМАНИЕ: Чтобы использовать данные функции, нужно изменить адрес начала        
BASIC-программы в основной памяти MSX-BASIC с &H8000 на &H8003; это действие
должно быть выполнено лишь однократно, и обязательно ПЕРЕД загрузкой
NestorBASIC'а. Это можно сделать двумя способами:

- В интерактивном режиме, напечатав следующие команды:

POKE &HF676,4
POKE &H8003,0
NEW

- Из программы на Бейсике. Этот способ лучше, так как в этой же программе можно,
следом, загрузить NestorBASIC. Первая строка программы должна быть такой:

1 'program.bas
10 IF PEEK(&HF676)<>4 THEN POKE &HF676,4:POKE &H8003,0:RUN"program.bas"
20 'From here, you can load NestorBASIC

Когда Вы актуализируете или запускаете программу, размещенную в сегменте,          
NestorBASIC сохраняет все переменные и массивы в сегменте 4; затем, копируется
программа из желаемого сегмента в основную память MSX-BASIC, и все ранее
сохраненные переменные помещаются после программы, после чего обновляются
соответствующие указатели в рабочей области MSX-BASIC. И, наконец, будет
осуществлено выполнение программы с первой строки, либо переход в
интерактивный режим - в зависимости от примененной функции (запуск или
актуализация).

Для того, чтобы программу на Бейсике можно было держать в сегменте и,              
в последствии, актуализировать или запустить, она должна там храниться со
специальным заголовком, содержащим информацию о её длинне, которая требуется
для конкатенации уже существующих переменных с новой программой. Есть функция
NestorBASIC'а, которая позволяет сохранить в файл активную программу с
таким заголовком. В дальнейшем, просто загрузите этот файл в какой-нибудь
сегмент с помощью дисковой функции, и программа готова к использованию - её
можно актуализировать или выполнить в любой момент.

6.1 ОШИБКИ

Очевидно, что если исполняется команда или строка, следующая за USR-функцией,      
которая актуализирует или запускает другую BASIC-программу, то это означает, что
мы находимся в состоянии ошибки. Возможна одна из двух ошибок:

- Ошибка -1, если заданный сегмент не существует. Эти функции поддерживают
VRAM-сегменты, но не сегмент 255.
- Ошибка -2, если памяти MSX-BASIC не достаточно для новой программы и переменных.
  Случается, если актуализируемая/запускаемая программа больше, чем исходная.

7. РАЗЛИЧНЫЕ ПРОЧИЕ ФУНКЦИИ

В этой группе собраны функции, предназначенные для:

- Вызова подпрограмм в машинном коде, находящихся в BIOS, SUB-BIOS, в основной     
  памяти BASIC'а, рабочей области системы или в сегменте ОЗУ (так называемые
  "пользовательские подпрограммы").
- Размещения строковых переменных в сегментах RAM и извлечения их оттуда.
- Вывода на экран строковых переменных в графическом режиме.
- Управления миганием (blink mode) в SCREEN 0.
- Назначения пользовательских прерываний (программы в машинном коде, находящиеся в 
  сегменте RAM, выполняемые каждое прерывание по таймеру 50/60 Гц).
- Воспроизведения звуковых эффектов на PSG(AY-3-8910), созданных в SEE версий 3.xx

Некоторые из этих функций требуют строковый массив F$ для передачи параметров и    
возврата результатов, в дополнение к целочисленному массиву P. Больше подробностей
о массиве F$ см. в разделе 4.

Некоторые из внутренних процедур NestorBASIC'а могут вызываться из других          
машинных подпрограмм пользователя и использоваться прерыванием, определяемым
пользователем. См. приложение 2 для детального описания использования этих
процедур.

Редактор SEE (sound effects editor) для создания звуковых эффектов под PSG был     
разработан группой Fuzzy Logic, и использование звуковых эффектов, сделанных в этом
редакторе, в коммерческих продуктах подразумевает отчисление небольшой суммы
авторам. Больше деталей в приложении 4.

8. ВОСПРОИЗВЕДЕНИЕ МУЗЫКИ

8.1. ИНИЦИАЛИЗАЦИЯ МУЗЫКАЛЬНОГО ПЛЕЕРА

NestorBASIC включает музыкальные проигрыватели Moonblaster 1.4 и Moonblaster Wave  
для MoonSound версии 1.05 .

Эти плееры не загружаются автоматически вместе с NestorBASIC'ом: вследствие своего 
большого размера, они не помещаются в сегмент ОЗУ NestorBASIC'а, и должны
загружаться в отдельный сегмент. Поэтому, чтобы использовать плеер, его нужно
загружать директивно. Одновременно может быть загружен лишь один плеер.

Функция 71 загружает и инициализирует желаемый плеер, оставляя его готовым к       
работе. Эта функция проверяет наличие 5-го сегмента и принадлежность его к
первичному мапперу: если это так, то плеер загружается в этот сегмент, после чего
сегмент более не доступен для программы пользователя. Если сегмент 5 не
существует, или подключен не к первичному мапперу, плеер не будет загружен, и 
функция выдаст ошибку.

Файл NBASIC.BIN содержит два варианта проигрывателя Moonblaster Wave: один для     
MSX2/2+ и Turbo-R в режиме Z80, а другой для Turbo-R в режиме R800. Если компьютер
это Turbo-R, то NestorBASIC определяет, какой вариант загружать, в соответствии с 
тем, в каком режиме работает процессор в момент вызова функции 71. Заметьте, что
если произведено переключение режима процессора, эту функцию нужно вызвать заново, 
чтобы загрузить соответствующий плеер: вариант для Z80 не работает в режиме R800,
а вариант для R800 привносит ненужное замедление системы в режиме Z80.

После того, как плеер загружен, происходит поиск аудиочипов, и все найденные       
помечаются как активные. Подробности о включении и отключении аудиочипов см. в
описании функции 73.

8.2. ВОЗМОЖНОСТИ ПЛЕЕРА

Как только плеер загружен, он может использоваться функциями NestorBASIC'а для:   

- Начала проигрывания музыки, предварительно загруженной в сегмент RAM (сегменты   
  VRAM не поддерживаются).
- Остановки воспроизведения музыки.
- Паузы/продолжения воспроизведения музыки.
- Постепенного затухания музыки, с выбором скорости затухания.
- Получения информации о воспроизводимой музыке (сегмент и начальный адрес, по
  которому она находится, название мелодии, набор сэмплов (samplekit) или набор
  PCM-инструментов (wavekit), текущая позиция и темп).
- Получения сведений о обнаруженных аудиочипах.
- Отключения аудиочипов, чтобы они не задействовались, несмотря на то, что были
  обнаружены. 
- Загрузки samplekit музыкального трека или wavekit для Moonsound из файла.

Во время проигрывания музыки, все функции NestorBASIC'а работают как обычно,       
включая проигрывание PSG эффектов и использование прерываний, определяемых
пользователем. Если NestorBASIC выгрузить из памяти, то воспроизводимая музыка
будет автоматически остановлена.

Плеер Moonblaster 1.4 помещается в 4.5Кб, следовательно - адресное пространство с 
&H1200 по &H3FFF сегмента 5 остается свободно, и может использоваться, например,
для хранения воспроизводимой музыки. Это не работает в случае с плеером
Moonblaster Wave, который занимает 5 сегмент полностью.

Аудиотреки Moonblaster 1.4 должны помещаться в один сегмент, поэтому их размеры   
ограничены 16Кб. Мелодии Moonblaster Wave могут занимать несколько сегментов
подряд, максимум 3: если при разборе воспроизводимых аудиоданных NestorBASIC 
доходит до адреса &H3FFF, процесс продолжается с адреса 0 следующего сегмента.

Чтобы загрузить музыкальный трек Moonblaster Wave из файла, можно воспользоваться 
следующим примером:

1000 'Loading a music through consecutive segments,
1010 'starting in segment S, address A
1020 F$(0)="music.mwm":P(2)=S:P(3)=A
1030 E=USR(31):IF E<>0 THEN 10000
1040 P(4)=&H4000:E=USR(33)
1050 IF (E<>0 AND E<>1 AND E<>199) THEN 10000
1060 IF E=0 THEN P(2)=P(2)+1:P(3)=0:GOTO 1040
1070 E=USR(32):IF E<>0 THEN 10000
...
10000 'Disk error E handling routine
...

ВНИМАНИЕ: Трек Moonblaster Wave может располагаться, начиная с любого адреса      
в сегменте, потому что он продолжится в начале следующего сегмента. Тем не менее,
как минимум первые 800 байт модуля, содержащие таблицу паттернов и различные
указатели, должны целиком быть помещены в один, начальный сегмент.

8.3 ОШИБКИ

Функции проигрывания музыки могут возвращать следующие коды ошибок:

- Ошибка 7, возвращается функцией активизации аудиочипов, функцией паузы и        
функцией затухания, если если какой-то из входных параметров некорректен.
- Ошибка 12, возвращается функцией старта воспроизведения и функцией включения
аудиочипов, если плеер не загружен. Остальные функции не выдадут ошибку в этом 
случае, они просто не сделают ничего.

Следующие ошибки могут произойти при выполнении функции запуска воспроизведения:  

-1: Указанный сегмент не существует, соотностится с VRAM, или это 255 сегмент.
12: Плеер не загружен.
13: Музыка была записана в режиме EDIT и не может быть воспроизведена
    (плеер Moonblaster 1.4).
    По данному адресу нет трека Moonblaster Wave, или
    там находится трек Moonblaster Wave записанный в режиме EDIT.
    (плеер Moonblaster Wave).
14: Уже проигрывается другая музыка в этот момент.

Функция загрузки wavekit'а для Moonsound, помимо ошибок работы с диском, может    
вернуть такую ошибку:

15: По данному смещению в указанном файле нет wavekit'а для Moonblaster Wave,
или там находится wavekit, сохраненный не в режиме USER.

ВНИМАНИЕ: Плеер Moonblaster 1.4 не умеет различать, являются ли данные по         
конкретному адресу в действительности саундтреком Moonblaster 1.4, и лишь всецело 
полагается на первый байт для определения того, что это данные трека,
сохраненного в режиме EDIT. Плеер Moonblaster Wave не имеет этой проблемы.

Функция загрузки плеера выдает такие же коды ошибок, как и функции для работы     
с диском, а также код -1 - если сегмент 5 не существует или не принадлежит
первичному мапперу.

ДЛЯ СПРАВКИ: Аудиотреки Moonblaster Wave могут быть сохранены в файл в режимах    
EDIT и USER. Файлы, сохраненные в режиме EDIT, содержат максимум информации о
музыкальном треке, и могут быть воспроизведены только в самом трекере (редакторе).
Файлы, сохраненные в режиме USER, могут быть проиграны плеерами, и пригодны для
встраивания в сторонние программы. Они предельно компактны, из них исключена вся
избыточная информация - не задействованные в мелодии паттерны/инструменты/тоны. 
Названия инструментов и тонов также не сохраняются.


9. ВЗАИМОДЕЙСТВИЕ С NESTORMAN И INTERNESTOR SUITE/LITE

NestorBASIC имеет специальные функции, которые позволяют взаимодействовать с      
NestorMan (резидентный динамический менеджер памяти для MSX-DOS 2), пакетом
InterNestor Suite (стэк TCP/IP для MSX-DOS 2) и InterNestor Lite (стэк TCP/IP 
для MSX-DOS 1/2), если эти программы запущены. Таким образом, возможна разработка
приложений на Бейсике, которые используют динамические блоки памяти and 
связанные списки, а также Internet-приложения. Чтобы узнать, запущен ли NestorMan 
и InterNestor Suite, можно воспользоваться функцией 81. Процедура проверки наличия
загруженного InterNestor Lite детально описана в разделе 9.4.

ВНИМАНИЕ: NestorMan и InterNestor Suite/Lite имеют собственную документацию,      
описывающую их функции и процедуры. Эти программы доступны для скачивания на
http://msx.konamiman.com

9.1. СЕГМЕНТЫ NESTORBASIC И СЕГМЕНТЫ NESTORMAN

NestorMan реализует систему логических сегментов, очень похожую на ту, что        
применяется в NestorBASIC. Оба пространства сегментов, NestorBASIC'а
и NestorMan'а, полностью независимы друг от друга, за несколькими исключениями:

- Сегменты 0, 1, 2 и 3 являются общими для NestorBASIC и NestorMan (в документации
к NestorMan's эти сегменты называются "TPA segments").

- Если, при резидентной загрузке NestorBASIC, NestorMan запущен - тогда логический
сегмент 4 NestorBASIC'а аллоцируется не с использованием механизмов DOS 2, как
остальные сегменты. Вместо этого, используется функция 7 NestorMan; таким образом,
4-му сегменту NestorBASIC'а присваивается, в свою очередь, номер сегмента
NestorMan (этот номер можно узнать посредством 81-й функции NestorBASIC'а). Этот
сегмент зарезервирован установкой аттрибута "exclusive", и поэтому не используется
NestorMan для выделения блоков памяти.

Если NestorMan и/или InterNestor Suite будут использоваться вместе с NestorBASIC, 
рекомендуется ограничить, с помощью функции 80, количество RAM сегментов, которые
будут использоваться NestorBASIC'ом. В противном случае, NestorBASIC зарезервирует
для себя все доступные сегменты, и NestorMan не сможет задействовать резервы ОЗУ
(необходимые для выделения блоков памяти, создания связанных списков и для
отправки/получения данных в/из Интернета).

Для вызыва функций NestorMan можно использовать 82-ю функцию; или можно           
использовать 58-ю функцию, указав хук EXTBIO (&HFFCA) в качестве адреса
перехода, занеся &H2202 в регистровую пару DE, и номер функции в регистр C.
См. описание функций в разделе 10.

9.2. ОБМЕН ДАННЫМИ МЕЖДУ NESTORBASIC И NESTORMAN

При использовании NestorMan из NestorBASIC'a, обычно Вам придется осуществлять    
передачу данных между сегментом NestorBASIC'а и сегментом NestorMan. Есть три
способа сделать это:

1) Если сегмент источника или назначения - это сегмент TPA (номер сегмента        
от 0 до 3), достаточно использовать соответствующую функцию NestorMan для
для передачи блока данных (функция номер 14), поскольку NestorMan и так видит 
эти сегменты.

2) Можно использовать сегмент 4 NestorBASIC'а как промежуточный буфер для         
пересылки. Например, предположим пересылку из NestorBASIC в NestorMan. S1 это
источник - сегмент NestorBASIC'а, S2 это назначение - сегмент NestorMan, и S3 это
номер сегмента NestorMan, соответствующий 4 сегменту NestorBASIC'a. Тогда, сначала 
делается пересылка S1->4 с помощью функции NestorBASIC'а (функция 10), 
и затем делается пересылка S3->S2 с использованием функции NestorMan (функция 14).

3) Функции 83 и 84 NestorBASIC'а осуществляют блочное копирование данных из       
сегмента NestorMan в сегмент NestorBASIC и наоборот.

Чтобы прочитать или записать единственный байт данных из/в сегмент NestorMan,     
проще всего использовать соответствующие функции, которые предоставляет NestorMan
(функции 12 и 13).

Помните, что некоторые функции NestorBASIC используют сегмент 4 как служебный     
буфер для временного размещения данных. См. раздел 10 или приложение 1, чтобы
узнать эти функции.

9.3. ИСПОЛЬЗОВАНИЕ INTERNESTOR SUITE

Методика, при использовании InterNestor Suite из NestorBASIC'а, схожа с той, что  
применяется для работы с NestorMan. Единственно, нужно иметь в виду
следующее:

- Функция 85 позволяет исполнять процедуры InterNestor Suite.

- Чтобы читать и записывать данные в сегменты InterNestor Suite (константы        
конфигурации и переменные), сначала нужно, используя функцию 81, выяснить номера 
сегментов модулей InterNestor Suite (каждый модуль занимает сегмент NestorMan),
а далее, использовать методы обмена данными, описанные в предыдущем разделе.

- Процедуры InterNestor Suite для чтения/записи данных TCP или датаграмм UDP      
допускают использование только сегментов TPA как источника/назначения данных или 
датаграмм. Для этой цели можно использовать последнюю часть сегмента NestorBASIC'а
(сегмент 0) как временный буфер. Это свободное пространство всегда будет, как
минимум, размером 600 байт, независимо от используемой версии NestorBASIC'а.  
Этого достаточно для размещения стандартной датаграммы до 576 байт длинной (или
для размещения блока данных TCP до 600 байт включительно).

Пример программы TCPCON-S.BAS, поставляемый с NestorBASIC'ом, иллюстрирует        
использование NestorBASIC'а совместно с InterNestor Suite.

ВНИМАНИЕ: InterNestor Suite это устаревшее ПО и не рекомендуется к использованию. 
Если Вам нужен рабочий TCP/IP стэк, посмотрите в сторону InterNestor Lite.

9.4. ИСПОЛЬЗОВАНИЕ INTERNESTOR LITE

InterNestor Lite это гораздо более простая программа, чем InterNestor Suite,      
поэтому использовать её из NestorBASIC'а также проще. Предоставляется
единственная функция (функция 86), которая позволяет выполнять несколько процедур 
из сегмента кода InterNestor Lite. Чтобы читать или писать в его сегмент данных,
необходимо использовать процедуры GET_VAR, SET_VAR и COPY_DATA, которые находятся
в сегменте кода.

Чтобы узнать, запущен InterNestor Lite или нет, используйте функцию 58 для вызова 
хука EXTBIO (адрес &HFFCA), передав A=0 и DE=&H2203. Если подпрограмма
вернула A<>0, значит InterNestor Lite запущен. Больше подробностей в описании
функции 86.

Многие из процедур InterNestor Lite используют адреса TPA как источник либо       
назначение для обмена данными с приложениями. Для таких процедур можно указать 
адреса выше &H8000, которые соответствуют основной памяти MSX-BASIC и рабочей 
области системы; или адреса ниже &H4000, которые соответствуют сегменту
NestorBASIC'а (сегмент 0).

В конце сегмента NestorBASIC есть свободная область, размер которой варьируется,  
в зависимости от версии NestorBASIC'а, но никогда не бывает меньше, чем 600 байт.
Эта область может быть использована как временный буфер для обмена данными с
InterNestor Lite. Другими словами, можно использовать диапазон от H3DA8 до &H3FFF
в качестве TPA области - источника или приемника для обмена данными между
NestorBASIC'ом и InterNestor Lite.

Пример программы TCPCON-L.BAS, поставляемый с NestorBASIC'ом, иллюстрирует        
использование NestorBASIC'а совместно с InterNestor Suite.
